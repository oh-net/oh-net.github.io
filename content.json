{"meta":{"title":"Coppid","subtitle":"Yet another note","description":"$$ Welcome $$","author":"John Doe","url":"https://www.cobsun.com"},"pages":[{"title":"","date":"2018-12-13T07:53:47.216Z","updated":"2018-12-13T04:53:17.804Z","comments":true,"path":"google7cf3f7dec20269a7.html","permalink":"https://www.cobsun.com/google7cf3f7dec20269a7.html","excerpt":"","text":"google-site-verification: google7cf3f7dec20269a7.html"}],"posts":[{"title":"获取翻墙软件方法大全","slug":"获取翻墙软件方法大全","date":"2019-01-14T04:46:03.000Z","updated":"2019-01-14T04:49:37.781Z","comments":true,"path":"2019/01/14/获取翻墙软件方法大全/","link":"","permalink":"https://www.cobsun.com/2019/01/14/获取翻墙软件方法大全/","excerpt":"","text":"##使用邮件获取 首先要介绍的是——邮件穿墙。俺个人认为，这个招数效果显著，使用简单，不失为首选。 ###邮箱的选择 先强调一点，此处介绍的邮件穿墙，必须得用国外的邮箱，才能确保安全并收到最好的效果。国内的邮箱，很有可能被党国审查。而且像腾讯之流，本来就助纣为虐，没准儿还主动帮着朝廷搞邮件审查。所以，国内的邮箱，万万使不得！ 考虑到Gmail已经被墙，当你用邮箱来获取翻墙工具时，首推 Hotmail（微软已经把它改名叫 LiveMail，不过俺叫 Hotmail叫惯了）。Hotmail 在2010年下半年，也学习 Gmail，引入了“全程的HTTPS加密”。此功能在防范 GFＷ 的敏感词过滤方面，疗效显著。不过，目前 Hotmail 的“全程 HTTPS 加密”功能，不是默认开启的。你需要到Hotmail的”选项”中手动开启一下。 ###Email如何能穿墙？ 由于国外的邮箱，其邮件服务器在国外，党国对其奈何不得。如果你用的邮箱还支持 HTTPS 全程加密（如 Gmail、Hotmail），GFＷ 连敏感词过滤的招数就使不上。 在这种情况下，朝廷如果要对付 Email 穿墙，只有如下两招： 1. 定点清除 对某个具体的 Email 提供商进行屏蔽，比如近期针对 Gmail 的封杀就属于定点清除。但是全球有那么多的Email提供商，党国要想一个个干掉，还是有点困难。 2. 全面封锁 全面封锁有可能是彻底断网（像埃及、利比亚那样），也可能是引入屏蔽白名单（只能上党国允许你上的网站，其它都禁止）。不管是彻底断网还是引入白名单，动静都比较大。朝廷如果胆敢这么干，只会加速自己的灭亡。 综上所述，Email 穿墙在近期内，还是一种比较可靠、比较稳定（用来获取翻墙工具）的手段。 ###使用邮件获取翻墙工具 有些提供翻墙软件的公司/组织，服务比较周到。他们会开设一个邮箱，用于自动回复翻墙工具。 提供“自由門”的动态网公司，开设了 freeget.one@gmail.com 邮箱。给这个邮箱发信，即可自动回复”自.由.門”软件。 对于另一个知名的翻墙工具 TOR，你可以发送标题为 help 的纯文本邮件到 gettor@torproject.org，也可以自动收到TOR的软件包。 ###使用邮件浏览网页 有不少国外的公司或组织提供了“利用邮件上网”的功能。这个功能，可能很多同学没听说过，俺简单讲讲。 假设你要访问某个网页，但是该网页在墙外，你看不到。咋办捏？你可以往某个特定的邮箱发一封邮件，在邮件的标题或者正文包含你要访问的URL网址，然后该邮箱就会自动给你回信，在信的内容或者附件中，就有你要看的网页了。 俺 Google 了一下，找到几个抓网页的邮件地址，大伙儿可以试试看。1234567submit@web2pdfconvert.combrowse@webinmail.comwww4mail@wm.ictp.trieste.itwww@web2mail.comsend@webtomail.co.cctext@pagegetter.compage@grabpage.org ##使用 Web 代理获取 说完邮件穿墙，再来说说 Web 代理。一旦手头的翻墙软件都失效，Web 代理是另一根救命稻草。 ###Web代理为何能穿墙？ 所谓的 Web 代理，通常指基于 HTTPS 协议的加密 Web 代理。由于它使用加密协议，GFＷ 不便于做敏感词过滤。所以，你有可能通过加密Web代理访问到被墙的网站。 ###如何操作？ Web 代理的操作步骤简单，就三步。 第1步 你首先得有一个浏览器 :)。 第2步 其次，到网上找一个加密的 Web 代理（这步是关键，也是难点）。如何找 Web 代理，得看大伙儿各自的本事了。（通常，搜索引擎用得越溜的，越容易找到）。可能某些天真的同学会问俺，为啥不直接把俺知道的Web代理贴出来给大伙儿用捏？在此，俺要灰常严肃地告诉这些天真的同学们，朝廷的走狗早就在看俺这个博客了。俺如果在这里贴 Web 代理的网址，岂不是正撞到枪口上，便宜了这帮走狗，让它们去封代理。 第3步 假设你运气好，顺利找到一个 Web 代理，要赶紧上反动网站去下载翻墙工具。因为 Web代理通常很短命，用不了几天可能就失效了（被封了）。 ##使用P2P下载获取 关于“P2P 下载”，想必大伙儿都很熟悉，俺就省点口水，不再扫盲P2P的概念了。 ###P2P为何能穿墙？ P2P 应用，由于其分布式的特点，使得 GFＷ 无法对所有的 Peer 都赶尽杀绝。而且很多 P2P 协议是加密传输的，GFＷ 难以搞敏感词过滤。 ###以 eMule 为例 P2P下载软件很多，俺就拿电骡来说事儿。 eMule俗称电骡，是电驴（eDonkey）的进化版，其官网在“这里”。该软件的相关介绍请看“维基百科”，俺不再多费口水。用 Emule 获取翻墙工具，也分三步走。 第1步 首先，当然是装eMule啦。你可以到其官方网站下载。如果其官网被封，也可以到国内的软件下载站点去找。eMule名气很大，很容易找到滴 :) 第2步 装好了 eMul 软件之后，你得联上某个下载服务器，才能下载。eMule 软件默认内置了几个服务器，如果这几个内置的服务器联不上（可能是被封，也可能是连接的用户数满了），你可以通过搜索引擎再找其它的服务器。由于全球有N多的 eMule/eDonkey 服务器，所以 GFＷ 难以全部干掉。 第3步 联上某个 eMule 服务器之后，你就可以搜索上面的文件了。像 自由门、无界 之类，名气比较大的，应该不难找到。 ###注意事项 通过 P2P 下载的翻墙工具，可能会含有病毒/木马之类的脏东西。下载后先用杀毒软件查一下。另外，“无界”、“赛风”、“自由門”等翻墙工具的 exe 是含有数字签名的，通过查看数字签名，能判断该 exe 是否被篡改了（不会验证数字签名的同学，翻墙看“这里”的介绍）。 ##通过图片文件方式获取 用图片文件来传播翻墙工具，是一种新思路。具体细节请看俺写的《用图片传播翻墙软件》。 简单地说，就是把包含翻墙工具的压缩文件，嵌入图片文件中。被嵌入的图片，格式上还是有效的。所以，大伙儿可以把这些图片上传到国内（墙内）那些支持贴图的网站。由于图片文件位于墙内，可以轻松下载。下载之后，用 7zip 或 WinRAR 都可以直接打开。 ##通过社会工程学手段获取 前2年，俺曾经写过一个《社会工程学扫盲》的系列。不过，这里说的“社会工程学”，泛指任何“用【非技术】手段获取翻墙工具”的招数。使用这些手段，不是靠技术能力，而是靠社交能力 :-) ###依靠外企的朋友 国内很多外企都有直通海外的网络专线，这个专线不会被 GFＷ 过滤。所以，如果你有朋友在外企上班，可以找他们帮忙下载翻墙工具，然后再拷给你。 ###找海外的朋友做人肉代理 如果你碰巧有熟人在国外，可以找他们帮忙下载翻墙工具。然后再通过邮件发给你。提醒一下，用 Email 发送翻墙工具，为了避免被GFＷ识别出来，最好是压缩一下并【加个口令】。GFＷ已经有针对压缩文件的深度检测能力，我等屁民得警惕啊！","categories":[],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"https://www.cobsun.com/tags/Proxy/"},{"name":"翻墙","slug":"翻墙","permalink":"https://www.cobsun.com/tags/翻墙/"}]},{"title":"如何快速在命令行中设置代理器","slug":"如何快速在命令行中设置代理器","date":"2018-12-22T15:17:40.000Z","updated":"2018-12-23T09:59:22.474Z","comments":true,"path":"2018/12/22/如何快速在命令行中设置代理器/","link":"","permalink":"https://www.cobsun.com/2018/12/22/如何快速在命令行中设置代理器/","excerpt":"我平时工作在 macOS 和 Linux 下。因为网络环境的问题，有些程序需要使用代理服务器才能顺利访问互联网。例如： pip、npm、brew 等等。好在这些命令都支持 ALL_PROXY、HTTPS_PROXY、HTTP_PROXY 这些变量。但是如果在 .bashrc 等文件中设置这些变量，又会导致全局无差别的使用代理服务器。所以，我写了一个叫做“proxied”的小脚本，放在了 “~/bin” 目录下，然后确保 “～/bin” 出现 PATH 变量中。","text":"我平时工作在 macOS 和 Linux 下。因为网络环境的问题，有些程序需要使用代理服务器才能顺利访问互联网。例如： pip、npm、brew 等等。好在这些命令都支持 ALL_PROXY、HTTPS_PROXY、HTTP_PROXY 这些变量。但是如果在 .bashrc 等文件中设置这些变量，又会导致全局无差别的使用代理服务器。所以，我写了一个叫做“proxied”的小脚本，放在了 “~/bin” 目录下，然后确保 “～/bin” 出现 PATH 变量中。 1234567#!/usr/bin/env shexport ALL_PROXY=socks5://&#123;socks5代理服务器地址:端口号&#125;export HTTP_PROXY=&#123;HTTP代理服务器地址:端口号&#125;export HTTPS_PROXY=&#123;HTTPS代理服务器地址:端口号&#125;exec $@ 之后，如果需要通过代理使用 pip， 只需要执行如下代码即可： 1$&gt; proxied pip install …","categories":[],"tags":[{"name":"代理","slug":"代理","permalink":"https://www.cobsun.com/tags/代理/"},{"name":"prosy","slug":"prosy","permalink":"https://www.cobsun.com/tags/prosy/"}]},{"title":"ubuntu16.04安装shadowsocks-qt5并支持chacha20-ietf-poly1305协议","slug":"ubuntu16-04安装shadowsocks-qt5并支持chacha20-ietf-poly1305协议","date":"2018-12-20T06:43:40.000Z","updated":"2018-12-20T06:51:32.549Z","comments":true,"path":"2018/12/20/ubuntu16-04安装shadowsocks-qt5并支持chacha20-ietf-poly1305协议/","link":"","permalink":"https://www.cobsun.com/2018/12/20/ubuntu16-04安装shadowsocks-qt5并支持chacha20-ietf-poly1305协议/","excerpt":"背景： 在 ubuntu 16.04 的机器上需要使用 shadowsocks-qt5，但是购买的服务器用的是 chacha20-ietf-poly1305 协议，采用 apt-get 安装的 shadowsocks-qt5 都是没有该协议的。","text":"背景： 在 ubuntu 16.04 的机器上需要使用 shadowsocks-qt5，但是购买的服务器用的是 chacha20-ietf-poly1305 协议，采用 apt-get 安装的 shadowsocks-qt5 都是没有该协议的。 解决方法： 采用源码安装 步骤：1.下载 shadowsocks-qt5 源码并安装相关依赖下载源码： 1git clone https://github.com/shadowsocks/shadowsocks-qt5 编译指南： https://github.com/shadowsocks/shadowsocks-qt5/wiki/Compiling 这贴一下编译指南： Make sure you’ve installed all dependent development packages (with -dev or -devel). cmake &gt;= 3.1.0 qt5-qtbase-gui &gt;= 5.2 (qtbase5 in Debian/Ubuntu) qrencode (libqrencode in Debian/Ubuntu) libQtShadowsocks &gt;= 1.10.0 (libqtshadowsocks in Debian/Ubuntu. DON’T use the trunk code) zbar (libzbar0 in Debian/Ubuntu) libappindicator (libappindicator1 in Debian/Ubuntu) Check libQtShadowsocks Compiling wiki if you need to build it yourself. 也就是说在编译前需要安装上面对应的库与工具 我们按照说明进行安装： 1sudo apt-get install cmake qtbase5-dev libqrencode-dev libzbar0 libappindicator1 libzbar-dev 这时候你会发现其中 libqtshadowsocks 库没有，因为这个也需要我们手动编译并安装 2.下载 libqtshadowsocks 源码下载源码： 1git clone https://github.com/shadowsocks/libQtShadowsocks 编译指南： https://github.com/shadowsocks/libQtShadowsocks/wiki/Compiling 继续贴编译指南： Qt &gt;= 5.5 Botan-2 &gt;= 2.3.0 Or Botan-1.10 (Not recommended) CMake &gt;= 3.1 A C++ Compiler that supports C++14 features (i.e. GCC &gt;= 4.9) 编译方法： 1234mkdir build &amp;&amp; cd buildcmake .. -DUSE_BOTAN2=ONmake -j4sudo make install 注意这里一定要加 -DUSE_BOTAN2=ON不然编译出来没有 chacha20-ietf-poly1305但是这时候你又会发现系统里面并没有 Botan-2，那怎么办呢？答案当然是—–自己编译（手动滑稽 3.下载 Botan2.3.0 源码并编译1234567wget https://botan.randombit.net/releases/Botan-2.3.0.tgztar xvf Botan-2.3.0.tgzcd Botan-2.3.0./configure.pymake -j4sudo make installsudo ldconfig 当完成 Botan2.3.0 的编译与安装后执行步骤 2中的 libqtshadowsocks 的编译 4. 编译shadowsocks-qt51234mkdir build &amp;&amp; cd buildcmake .. make -j4sudo make install 5. Enjoy终端输入 1ss-qt5 启动 shadowsocks-qt5，这时候你会发现已经支持 chacha20-ietf-poly1305 协议了","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.cobsun.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.cobsun.com/tags/ubuntu/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://www.cobsun.com/tags/shadowsocks/"}]},{"title":"各平台主机 IO 速度测试","slug":"check-some-clouds-disk-speed-on-linux","date":"2018-12-17T03:17:39.000Z","updated":"2018-12-17T03:28:19.658Z","comments":true,"path":"2018/12/17/check-some-clouds-disk-speed-on-linux/","link":"","permalink":"https://www.cobsun.com/2018/12/17/check-some-clouds-disk-speed-on-linux/","excerpt":"","text":"说明使用的命令1hdparm -Tt /dev/sda 都只测了两遍，仅作为参考 PC-HDD 500G123/dev/sda: Timing cached reads: 24752 MB in 1.99 seconds = 12411.35 MB/secTiming buffered disk reads: 598 MB in 3.01 seconds = 198.85 MB/sec Linode-SSD 1C1G 25G123/dev/sda:Timing cached reads: 11034 MB in 1.99 seconds = 5539.69 MB/secTiming buffered disk reads: 1916 MB in 3.00 seconds = 638.47 MB/sec Aliyun-SSD 1C1G 20G123/dev/vda:Timing cached reads: 18290 MB in 1.99 seconds = 9174.21 MB/secTiming buffered disk reads: 278 MB in 3.01 seconds = 92.50 MB/sec Kdatacenter-SSD 1C1G 100G123/dev/vda:Timing cached reads: 12728 MB in 2.00 seconds = 6367.04 MB/secTiming buffered disk reads: 850 MB in 3.00 seconds = 283.29 MB/sec","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.cobsun.com/tags/linux/"}]},{"title":"一行命令删除文件中的空行","slug":"e4-b8-80-e8-a1-8c-e5-91-bd-e4-bb-a4-e5-88-a0-e9-99-a4-e6-96-87-e4-bb-b6-e4-b8-ad-e7-9a-84-e7-a9-ba-e8-a1-8c","date":"2018-08-09T03:50:02.000Z","updated":"2018-12-12T09:05:36.259Z","comments":false,"path":"2018/08/09/e4-b8-80-e8-a1-8c-e5-91-bd-e4-bb-a4-e5-88-a0-e9-99-a4-e6-96-87-e4-bb-b6-e4-b8-ad-e7-9a-84-e7-a9-ba-e8-a1-8c/","link":"","permalink":"https://www.cobsun.com/2018/08/09/e4-b8-80-e8-a1-8c-e5-91-bd-e4-bb-a4-e5-88-a0-e9-99-a4-e6-96-87-e4-bb-b6-e4-b8-ad-e7-9a-84-e7-a9-ba-e8-a1-8c/","excerpt":"","text":"从另一个地方复制的文字, 总会携带很多奇奇怪怪的空白 单独占一行, 没实质意义. 比如 空格 全角空格 制表符 换行符 教你用 vim 一条命令删掉::g/^\\(\\%u3000\\|[\\t ]\\)*$/d 解释: 使用 global(g) 命令 删除(d)文件中 匹配空白的行 ^: 匹配行开始 \\(\\): 要纳入检测的空白字符集合 \\%u3000: 匹配全角字符 \\|: “或” 条件 [\\t ]: 匹配制表符(\\t)或空格 *: 集合中的字符可以任意次数重复 $: 匹配行结尾 ps: 通过 ga 命令可以显示当前光标下字符的编码,例如: &lt;考&gt; 32771, 十六进制 8003, 八进制 100003","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://www.cobsun.com/tags/vim/"},{"name":"命令","slug":"命令","permalink":"https://www.cobsun.com/tags/命令/"},{"name":"替换","slug":"替换","permalink":"https://www.cobsun.com/tags/替换/"}]},{"title":"NAT类型科普及一些简单提升NAT类型的方法","slug":"nat-setting-and-tips","date":"2018-06-05T08:34:03.000Z","updated":"2018-12-17T08:09:52.991Z","comments":true,"path":"2018/06/05/nat-setting-and-tips/","link":"","permalink":"https://www.cobsun.com/2018/06/05/nat-setting-and-tips/","excerpt":"首先可以在百度百科了解到什么是NAT，传送门→“NAT科普”然后呢，看了那么多我们大概就知道了一些关于NAT的基本知识， “定义”、 “功能”、 “实现方式”及 “类型”","text":"首先可以在百度百科了解到什么是NAT，传送门→“NAT科普”然后呢，看了那么多我们大概就知道了一些关于NAT的基本知识， “定义”、 “功能”、 “实现方式”及 “类型” 提升NAT类型的好处：浏览网页、观看视频、游戏等更顺畅，下载速度更稳定快速， 特别是对那些玩ED2K/PT下载、PS4/XBox主机游戏的，提升NAT类型后更有可能获取到HigtID、更容易进入游戏房间连线等。 好了，废话有点多了。要提升NAT类型，我们必须知道NAT的4个类型：NAT1、NAT2、NAT3、NAT4。它们分别对应（详情见百度百科）： NAT1 → Full Cone NAT NAT2 → Address-Restricted Cone NAT NAT3 → Port-Restricted Cone NAT NAT4 → Symmetric NAT 说些比较重要的前话：路由器少一层是一层，这样越有可能得到NAT1和NAT2这两类NAT类型。 建议家里的网路是以下两种拓扑类型： 猫桥接→主路由（拨号连接外网用）→副路由（纯AP模式，扩展信号） 光猫拨号（直接充当主路由）→副路由（纯AP模式，扩展信号） 这样的好处是桥接和纯AP是不进行NAT的，而是SWitch，所以不会导致多一层NAT。 如果你的网络是 NAT1，那这是最宽松的网络环境，你想做什么，基本没啥限制； 如果是 NAT4 的话，这是最严格的网络环境，可能会玩不了游戏、下载都没速度； 一般，我们家里的设备都是通过光猫桥接+无线路由器拨号的形式连接到外网的， 此时，基本是NAT2和NAT3，正常情况对看网页、游戏及下载都没有过多的限制。但是，现在个别网络游戏严格要求你的网络环境必须是“NAT2”以上（NAT2和NAT1），才能进行游戏。 而你的网络环境又是 NAT3 及 NAT4,那到底该怎么办呢？下面我们介绍一些简单提升NAT类型的方法 NAT穿透 如果你的路由器有启用“Full Cone”、“STUN”、“TURN”、“ICE”、“uPnP”等功能，果断都启用了。如果没有的话，你的路由器差不多可以扔了，因为现在的路由器“uPnP”基本是标配，连这都没有，那你的路由器是有多古董。 如果你的路由器没有以上功能，那可以找下有没有“DMZ”功能（什么是“DMZ”，请问度娘 → DMZ ）,有的话，可以启用它，并把你要提升NAT类型的主机IP地址设置好。 （一般建议有“Full Cone”、“uPnP”等，就不要开 DMZ 了，除非你是PS4/XBox这类游戏主机要提升NAT类型） 在Windows上把以下三个服务设置为自动启动，并启动该服务： 一般这三个服务都会被奇虎360等带启动项优化的软件当做无用启动项被“优化”成禁止启动。怎么手动设置为自动启动，并启动，详情问 → 度娘 Function Discovery Provider Host Function Discovery Resource Publication SSDP Discovery 在 Windows 防火墙，放行你需要提升NAT类型的软件或者游戏程序（EXE程序或者UWP程序）， 如果你不会放行，也可以直接关闭 Windows 防火墙。（一般不推荐这样做，还是老话，不懂问“度娘”）第4步很重要，这步没做，等于其它的全是在做无用功。 如果你的设备是通过电脑共享网络的形式上网的，建议把这个服务也打开：UPnP Device Host 以上，能弄的都弄了，这样你的网络环境就会越好，甚至NAT1都没有问题。","categories":[{"name":"互联网","slug":"互联网","permalink":"https://www.cobsun.com/categories/互联网/"}],"tags":[{"name":"NAT","slug":"NAT","permalink":"https://www.cobsun.com/tags/NAT/"}]},{"title":"使用SNK密钥文件保护你的DLL和代码不被反编译教程","slug":"e4-bd-bf-e7-94-a8snk-e5-af-86-e9-92-a5-e6-96-87-e4-bb-b6-e4-bf-9d-e6-8a-a4-e4-bd-a0-e7-9a-84dll-e5-92-8c-e4-bb-a3-e7-a0-81-e4-b8-8d-e8-a2-ab-e5-8f-8d-e7-bc-96-e8-af-91-e6-95-99-e7-a8-8b","date":"2017-12-22T08:45:46.000Z","updated":"2018-12-12T09:05:36.324Z","comments":true,"path":"2017/12/22/e4-bd-bf-e7-94-a8snk-e5-af-86-e9-92-a5-e6-96-87-e4-bb-b6-e4-bf-9d-e6-8a-a4-e4-bd-a0-e7-9a-84dll-e5-92-8c-e4-bb-a3-e7-a0-81-e4-b8-8d-e8-a2-ab-e5-8f-8d-e7-bc-96-e8-af-91-e6-95-99-e7-a8-8b/","link":"","permalink":"https://www.cobsun.com/2017/12/22/e4-bd-bf-e7-94-a8snk-e5-af-86-e9-92-a5-e6-96-87-e4-bb-b6-e4-bf-9d-e6-8a-a4-e4-bd-a0-e7-9a-84dll-e5-92-8c-e4-bb-a3-e7-a0-81-e4-b8-8d-e8-a2-ab-e5-8f-8d-e7-bc-96-e8-af-91-e6-95-99-e7-a8-8b/","excerpt":"","text":"大家做项目开发一般都是分层的，比如UI层，业务层，数据访问层。业务层引用数据访问层的DLL(比如dataAccess.dll)，并使用dataAccess.dll中的方法。当项目完成并给客户用了，可有些心里BT的客户这个时候也可以请个稍微懂NET的人来引用你的dataAccess.dll并调用其中的方法搞破坏。比如可以直接使用里面的ChangePwd(string UserName,string Pwd)方法把其他用户的密码改了，这个时候就你就……. 好了，该开始说怎么保护我们的代码了： 首先我们需要把我们的程序集做成强命名的程序集。这里我们在.NET 命令提示中输入sn -k c:test.snk 创建一个新的随机密钥对并将其存储在 c:test.snk 中 然后新建立类库ClassLibrary1，里面只有个类文件Class1.cs，代码如下： using System; namespace ClassLibrary1 { public class Class1 { public Class1() { // // TODO: 在此处添加构造函数逻辑 // } public string Insert() { return &quot;ok&quot;; } } } AssemblyInfo.cs代码： //............其他的就用默认 [assembly: AssemblyKeyFile(&quot;c:test.snk&quot;)] // 连接上面用强命名工具SN.exe生成的文件. 接着创建个WindowApplication来调用我们的ClassLibrary1，代码： private void button1_Click(object sender, System.EventArgs e) { MessageBox.Show(new ClassLibrary1.Class1().Insert()); } 不修改WindowApplication的AssemblyInfo.cs。 在这里就可以直接运行了，不过大家都看的出来，这样是能成功调用Class1中的方法的。 现在让我们来修改下Class1.cs，代码： using System; using System.Security.Permissions; namespace ClassLibrary1 { [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = &quot;00240000048000009400000006020000002400005253413100040000010001000551684edd1600&quot;+ &quot;8ccbdd337b1cf1490490d97fe0048c5f3629cc4f5104578499eace9b2a94115022edd620def472&quot;+ &quot;8b4f088291cfa77a40659afba611fdafbb7894b93a64049d439936bd0cd8dc0704625aeb735892&quot;+ &quot;e9eb3f910a49a2925af10515d935654d7adac5567ff6d780d23d587de0ff4d271da7b30680fa88&quot;+ &quot;a47a4ba4&quot;)] public class Class1 { public Class1() { // // TODO: 在此处添加构造函数逻辑 // } public string Insert() { return &quot;ok&quot;; } } } 然后再编译后运行windowapplication调用class1中的方法就会出错。 这里的StrongNameIdentityPermissionAttribute是NET提供的CAS(Code Access Security)中的1个类，具体可参考MSDN， SecurityAction.LinkDemand 是要求直接调用方已被授予了指定的权限，这里即windowapplication要授予了权限才行， 如果使用SecurityAction.Demand要求调用堆栈中的所有高级调用方都已被授予了当前权限对象所指定的权限。 他们的区别是： 如果windowapplication已授权访问，而还有个windowapplication2(未授权访问)通过调用windowapplication中的button1_Click方法来调用class1，这个时候如果使用SecurityAction.LinkDemand就能成功调用， 而使用SecurityAction.Demand windowapplication2就不能调用，windowapplication 在这2种情况下都能调用。 说到这里大家一定再问PublicKey＝后面一串那么长的字符串怎么来。PublicKey后面的字符串是你开始生成的c:test.snk文件中保存的公钥。那怎么才能看到这个公钥了，照样是用SN.EXE。 输入sn -p c:test.snk c:publicKey.snk (从 test.snk 中提取公钥并将其存储在 publicKey.snk 中) 再输入sn -tp c:publicKey.snk (显示公钥信息) 上面这个命令就能看到PublicKey后面的字符串了，还想什么啊，把那字符串copy下来啊。 最后大家一定在关心这个时候windowapplication 要怎么调用class1了，其实也简单，只要把windowapplication 的AssemblyInfo.cs修改为： [assembly: AssemblyKeyFile(&quot;c:test.snk&quot;)] 到这里就一切OK了，大家都看到最关键的就是test.snk文件了，所以一定要保护好你自己的test.snk文件。","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://www.cobsun.com/tags/c/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://www.cobsun.com/tags/逆向工程/"}]},{"title":"[shadowsocks error ] undefined symbol: EVP_CIPHER_CTX_cleanup","slug":"ssundefined-symbol-evp-cipher-ctx-cleanup","date":"2017-10-28T15:54:52.000Z","updated":"2018-12-12T09:27:29.851Z","comments":false,"path":"2017/10/28/ssundefined-symbol-evp-cipher-ctx-cleanup/","link":"","permalink":"https://www.cobsun.com/2017/10/28/ssundefined-symbol-evp-cipher-ctx-cleanup/","excerpt":"","text":"Installed ss , when I try start with sslocal -c ss.json, its catch an error : undefined symbol: EVP_CIPHER_CTX_cleanup Using compalie to install ss, and, try using python-pip &amp; pip install shadowscks did not work, python version: Python, 2.7.13 the answer from : http://www.cnblogs.com/lzhd24/p/6686803.html 修改方法： 用vi打开文件：vi /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py 跳转到52行（shadowsocks2.8.2版本，其他版本搜索一下cleanup） 进入编辑模式 将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,) 改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,) 再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx) 改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx) 保存并退出 启动shadowsocks服务：service shadowsocks start 或 sslocal -c ss配置文件目录","categories":[{"name":"互联网","slug":"互联网","permalink":"https://www.cobsun.com/categories/互联网/"}],"tags":[{"name":"代理","slug":"代理","permalink":"https://www.cobsun.com/tags/代理/"},{"name":"openssl","slug":"openssl","permalink":"https://www.cobsun.com/tags/openssl/"},{"name":"python","slug":"python","permalink":"https://www.cobsun.com/tags/python/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://www.cobsun.com/tags/shadowsocks/"}]},{"title":"让终端走代理的几种方法","slug":"e8-ae-a9-e7-bb-88-e7-ab-af-e8-b5-b0-e4-bb-a3-e7-90-86-e7-9a-84-e5-87-a0-e7-a7-8d-e6-96-b9-e6-b3-95","date":"2017-10-08T13:54:59.000Z","updated":"2018-12-12T09:13:19.486Z","comments":false,"path":"2017/10/08/e8-ae-a9-e7-bb-88-e7-ab-af-e8-b5-b0-e4-bb-a3-e7-90-86-e7-9a-84-e5-87-a0-e7-a7-8d-e6-96-b9-e6-b3-95/","link":"","permalink":"https://www.cobsun.com/2017/10/08/e8-ae-a9-e7-bb-88-e7-ab-af-e8-b5-b0-e4-bb-a3-e7-90-86-e7-9a-84-e5-87-a0-e7-a7-8d-e6-96-b9-e6-b3-95/","excerpt":"","text":"方法1:在终端中直接运行命令 export http_proxy=http://proxyAddress:port 这个办法的好处是简单直接，并且影响面很小（只对当前终端有效，退出就不行了）。 如果你用的是ss代理，在当前终端运行以下命令，那么wget curl 这类网络命令都会经过ss代理 export ALL_PROXY=socks5://127.0.0.1:1080 方法2:把代理服务器地址写入shell配置文件.bashrc或者.zshrc 直接在.bashrc或者.zshrc添加下面内容 export http_proxy=&quot;http://localhost:port&quot; export https_proxy=&quot;http://localhost:port&quot; 以使用shadowsocks代理为例，ss的代理端口为1080,那么应该设置为 export http_proxy=&quot;socks5://127.0.0.1:1080&quot; export https_proxy=&quot;socks5://127.0.0.1:1080&quot; 或者直接设置ALL_PROXY export ALL_PROXY=socks5://127.0.0.1:1080 localhost就是一个域名，域名默认指向 127.0.0.1，两者是一样的。 然后ESC后:wq保存文件，接着在终端中执行 source ~/.bashrc 或者退出当前终端再起一个终端。 这个办法的好处是把代理服务器永久保存了，下次就可以直接用了。 或者通过设置alias简写来简化操作，每次要用的时候输入setproxy，不用了就unsetproxy。 alias setproxy=&quot;export ALL_PROXY=socks5://127.0.0.1:1080&quot; alias unsetproxy=&quot;unset ALL_PROXY&quot; alias ip=&quot;curl -i http://ip.cn&quot; 方法3:改相应工具的配置，比如apt的配置 sudo vim /etc/apt/apt.conf 在文件末尾加入下面这行 Acquire::http::Proxy &quot;http://proxyAddress:port&quot; 保存apt.conf文件即可。 关于apt的代理设置可以参考这里 关于git的代理设置看这里:用shadowsocks加速git clone 方法4(推荐):利用proxychains在终端使用socks5代理 补充： 如果代理服务器需要登陆，这时可以直接把用户名和密码写进去 http_proxy=http://userName:password@proxyAddress:port","categories":[{"name":"互联网","slug":"互联网","permalink":"https://www.cobsun.com/categories/互联网/"}],"tags":[{"name":"终端","slug":"终端","permalink":"https://www.cobsun.com/tags/终端/"},{"name":"proxy","slug":"proxy","permalink":"https://www.cobsun.com/tags/proxy/"},{"name":"代理","slug":"代理","permalink":"https://www.cobsun.com/tags/代理/"}]},{"title":"Ubuntu ocserv搭建","slug":"ubuntu-ocserv-e6-90-ad-e5-bb-ba","date":"2017-09-26T23:18:35.000Z","updated":"2018-12-12T09:24:02.249Z","comments":false,"path":"2017/09/27/ubuntu-ocserv-e6-90-ad-e5-bb-ba/","link":"","permalink":"https://www.cobsun.com/2017/09/27/ubuntu-ocserv-e6-90-ad-e5-bb-ba/","excerpt":"","text":"Ubuntu ocserv搭建Android上上推，用shadowsocks那是一个舒心。可是换了iOS，就没那么方便的自动切换代理了，比较普遍的是pac或apn。 pac就wifi下还说得过去，搞个树莓派什么的玩玩，也挺geek的，4G网络别想了。apn这货不是很安全，http代理那尿性也知道了＝＝。 后来发现Cisco AnyConnect，Cisco的VPN肯定比其他代理靠谱多了，要的就是安全、稳定与高效。另外一个好处就是，可以按需连接，不用全局开代理。全局就是国内的站点又绕了地球一圈，又回来，蛋疼＝＝。 要搭建AnyConnect的VPN，需要ocserv。截止到今天，最新的版本是0.10.7，可以在官方的changelog页面，找到版本相关信息。 ocserv的配置还是比较变态的，虽然官方的文档说得很清楚，但还是有点晕晕的，涉及方方面面的知识挺杂的。网上的中文教程也是质量不高，普遍的技术类的中文教程貌似都这样。怕自己以后忘了，或者也有同样想搭建ocserv的童鞋，所以纪录下。 以下教程基于: Ubuntu 14.04 x64 ocserv 0.10.7 首先，你需要一个女朋友(大雾，不是，需要一台Ubuntu 14.04 x64的VPS。 就最近来说，digitalocean的速度好慢好慢?，新加坡或旧金山都慢出翔?了，福州电信或联通是这样。 vultr东京??的速度还不错。 有需要的童鞋，可以用我的邀请码，猛戳?http://www.vultr.com/?ref=6829224。还是那么想要digitalocean，咱也有邀请码?，猛戳?https://www.digitalocean.com/?refcode=bd778c035a7e。 小广告打完了，不废话啦，开始正题。 准备工作下载 ocserv 最新的包:wget ftp://ftp.infradead.org/pub/ocserv/ocserv-0.10.7.tar.xz 解压tar -xf ocserv-0.10.7.tar.xz 安装依赖apt-get install build-essential pkg-config libgnutls28-dev libwrap0-dev libpam0g-dev libseccomp-dev libreadline-dev libnl-route-3-dev 编译&amp;安装cd ocserv-0.10.7/ ./configure make make install 安装nginx(后续下载user.p12，需要用到)apt-get install nginx 证书相关创建一个新的目录，放ocserv相关的配置文件、秘钥与证书mkdir /etc/ocserv cd /etc/ocserv 创建 ca.tmplcn = &quot;fff&quot; organization = &quot;fff&quot; serial = 1 expiration_days = 3650 ca signing_key cert_signing_key crl_signing_key 生成 ca 秘钥与证书certtool --generate-privkey --outfile ca-key.pem certtool --generate-self-signed --load-privkey ca-key.pem --template ca.tmpl --outfile ca-cert.pem 创建 server.tmpl，111.111.111.111替换成你自己VPS的ipcn = &quot;111.111.111.111&quot; organization = &quot;fff&quot; expiration_days = 3650 signing_key encryption_key tls_www_server 生成 server 秘钥与证书certtool --generate-privkey --outfile server-key.pem certtool --generate-certificate --load-privkey server-key.pem --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem --template server.tmpl --outfile server-cert.pem 创建 user.tmpl, uid这个很多教程都忽略了，没这个，证书验证登陆就不能用了，这边自己也是浪费了好多时间。cn = &quot;fff&quot; unit = &quot;fff&quot; uid = &quot;fff&quot; expiration_days = 3650 signing_key tls_www_client 生成 user 秘钥与证书certtool --generate-privkey --outfile user-key.pem certtool --generate-certificate --load-privkey user-key.pem --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem --template user.tmpl --outfile user-cert.pem 将证书转换为 PKCS12，会提示输入两次密码，随便输，一样就可以咯。待会iOS客户端导入证书的时候，会提示输入密码，这个密码就是现在要输的密码。openssl pkcs12 -export -inkey user-key.pem -in user-cert.pem -certfile ca-cert.pem -out user.p12 将生成好的user.p12，拷贝到nginx的http服务目录，方便下载cp user.p12 /usr/share/nginx/html 拷贝默认配置文件cp ~/ocserv-0.10.7/doc/sample.config config 证书配置相关说明fff 是神马，它是一个很神秘的组织，每个人都举着火把?。 expiration_days 是证书过期的时间，时间单位：天。 配置相关修改 config，auth改为证书认证的方式，注释掉其他 auth =开头的auth = &quot;certificate&quot; 配置 server 秘钥与证书server-cert = /etc/ocserv/server-cert.pem server-key = /etc/ocserv/server-key.pem 配置 ca 证书ca-cert = /etc/ocserv/ca-cert.pem 配置端口号tcp-port = 2333 udp-port = 2333 修改dnsdns = 8.8.8.8 dns = 8.8.4.4 确保以下两个都是 true，貌似默认就是了try-mtu-discovery = true cisco-client-compat = true 修改route，咱这边是都注释掉，按需修改。可以参考 kevinzhow 童鞋的配置。修改no route，咱这边是保持默认配置，这个添加完，貌似就不走代理，不过客户端那边也可以配置，就没去动它，按需修改修改/etc/sysctl.conf，把下面注释去掉net.ipv4.ip_forward=1 重新加载下，让 /etc/sysctl.conf 生效sysctl -p /etc/sysctl.conf 打开 TCP 和 UDP 端口，比如刚才的端口是2333，那么现在也要是2333iptables -t filter -A INPUT -p tcp -m tcp --dport 2333 -j ACCEPT iptables -t filter -A INPUT -p udp -m udp --dport 2333 -j ACCEPT iptables -t nat -A POSTROUTING -j MASQUERADE debug模式打开ocserv --config=/etc/ocserv/config -f -d 1 查看端口占用，比如查看2333端口lsof -i:2333 干掉占用端口的进程，假设刚才占用2333端口的pid是12345kill 9 12345 iOS客户端配置安装Cisco AnyConnectApp Stroe地址https://itunes.apple.com/cn/app/cisco-anyconnect/id392790924 导入证书诊断 &gt; 证书 > 导入用户证书，会提示你输入URL，记得加http://，假设你的VPS的ip 是 111.111.111.111 ,拷贝到nginx目录的是user.p12，就应该输入 http://111.111.111.111/user.p12 添加连接连接 > 添加VPN连接 说明，随便填 服务器地址，假设你的VPS的ip 是 111.111.111.111，端口是 2333，那么就是 111.111.111.111:2333，这边就不需要前面加http://了。 高级 &gt; 证书，选择你刚才导入的那个证书 高级 &gt; 按需连接，打开，出现 域列表，永不连接 那边可以添加一下常用的国内站点 ####设置 设置 &gt; 阻止不信任的服务器，这个关掉，不然使用自己颁发的证书会有问题 设置 > VPN FIPS模式，这个打开，貌似会比较稳定，心里作用吧(¬_¬)","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"anyconnect","slug":"anyconnect","permalink":"https://www.cobsun.com/tags/anyconnect/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.cobsun.com/tags/ubuntu/"},{"name":"ocserv","slug":"ocserv","permalink":"https://www.cobsun.com/tags/ocserv/"},{"name":"思科","slug":"思科","permalink":"https://www.cobsun.com/tags/思科/"}]},{"title":"【转】利用反向ssh从外网访问内网主机","slug":"use-reverse-SSH-to-access-intranet-hosts-from-the-external-network","date":"2017-09-15T10:41:06.000Z","updated":"2018-12-18T08:42:16.244Z","comments":true,"path":"2017/09/15/use-reverse-SSH-to-access-intranet-hosts-from-the-external-network/","link":"","permalink":"https://www.cobsun.com/2017/09/15/use-reverse-SSH-to-access-intranet-hosts-from-the-external-network/","excerpt":"","text":"前言最近遇到一个问题，就是过几天我需要离开学校，而且到时候仍然想登陆校园网里的一台服务器进行工作；但是我又没有校园网网关的操作权限，不能做端口映射，也不能搞到校园网内部主机的外网 ip，而且学校自己提供的 vpn 又根本没法用。研究了半天，总算找到了一个比较不错的利用反向ssh(reverse ssh tunnel)进行内网登陆的解决方案。 工作原理之所以很多转发的方法无法应用在这里，就是因为内网主机对外网其实是不可见的，也就是说外部主机不能用一般的方法访问到内部主机。那么我们就想了，能不能用内网主机找外网主机，找到之后再把这条内网主机登陆外网的信道转换成外网主机登陆内网的信道呢？辛运的是，这个方法的确是可行的，这也就是所谓反向 ssh 最通俗的理解，这就像寄信一样：虽然我不知道你的地址，但是你知道我的地址，那么你就先给我写封信，告诉我你的地址，然后我不就可以回信给你了么？ 操作步骤由于我们自己使用的电脑未必有外网 ip，因此我们需要一个有固定外网ip的服务器(随便搞个腾讯云阿里云的小机子就行)，然后用这台服务器与内网的机子进行通信，我们到时候要先登陆自己的服务器，然后再利用这个服务器去访问内网的主机。 1、准备好有固定 ip 的服务器 A，以及待访问的内网机器 B。 两者都开着 sshd 服务，端口号默认都是 22。顺便做好 ssh 免密码登陆。2、内网主机B主动连接服务器A，执行以下命令： 1$ ssh -NfR 1111:localhost:22 username@servername -p 22 这条命令的意思是在后台执行(-f)，不实际连接而是做 port forwarding(-N)，做反向 ssh(-R) ，将远程服务器的 1111 端口映射成连接本机(B)与该服务器的反向 ssh 的端口。附：这里有必要加强一下记忆，这个端口号一不小心就容易搞混。。man文档中的参数命令是这样的： 1-R \\[bind_address:\\]port:host:hostport bind_address 以及其后面的 port 是指远程主机的 ip 以及端口，host 以及其后的 hostport 是指本机的 ip 和端口。由于 ssh 命令本身需要远程主机的 ip(上上条命令中的 servername)，因此这个 bind_address 原则上是可以省略的。 执行完这条命令，我们可以在服务器A上看到他的 1111 端口已经开始监听：123$ ss -ant |grep 1111LISTEN 0 128 127.0.0.1:1111 *:* 3、在上面的操作中，这个 1111 端口就已经映射成了内网 主机 B 的 22 端口了，现在我们只要ssh到自己的这个端口就行了。 在服务器A中执行： 1$ ssh username@localhost -p1111 这样就成功的登陆了内网的主机了。 功能优化上面的做法其实有一个问题，就是反向ssh可能会不稳定，主机B对服务器A的端口映射可能会断掉，那么这时候就需要主机B重新链接，而显然远在外地的我无法登陆B。。。 这其实有一个非常简单的解决方案，就是用 autossh 替代步骤2中的 ssh： 1$ autossh -M 2222 -NfR 1111:localhost:22 username@servername -p 22 后面的参数跟ssh都一样，只是多了一个 -M 参数，这个参数的意思就是用本机的 2222 端口来监听 ssh，每当他断了就重新把他连起来。。。不过man文档中也说了，这个端口又叫 echo port，他其实是有一对端口的形式出现，第二个端口就是这个端口号加一。因此我们要保证这个端口号和这个端口号加一的端口号不被占用。 参考资料SSH反向连接及Autossh","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.cobsun.com/tags/linux/"}]},{"title":"追加内容到文件末尾的几种常用方法","slug":"Append-content-to-the-end-of-the-file","date":"2017-09-15T04:26:22.000Z","updated":"2018-12-21T06:25:47.178Z","comments":true,"path":"2017/09/15/Append-content-to-the-end-of-the-file/","link":"","permalink":"https://www.cobsun.com/2017/09/15/Append-content-to-the-end-of-the-file/","excerpt":"使用 FileOutputStream 或者 FileWriter 时，将方法的第二个参数设置为 true 即可使用追加的方式写文件 下面是示例代码：","text":"使用 FileOutputStream 或者 FileWriter 时，将方法的第二个参数设置为 true 即可使用追加的方式写文件 下面是示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.io.BufferedWriter; import java.io.FileOutputStream; import java.io.FileWriter; import java.io.IOException; import java.io.OutputStreamWriter; import java.io.RandomAccessFile; /** * 描述：追加内容到文件末尾 * @author Administrator * */ public class WriteStreamAppend &#123; /** * 追加文件：使用FileOutputStream，在构造FileOutputStream时，把第二个参数设为true * * @param fileName * @param content */ public static void method1(String file, String conent) &#123; BufferedWriter out = null; try &#123; out = new BufferedWriter(new OutputStreamWriter( new FileOutputStream(file, true))); out.write(conent); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 追加文件：使用FileWriter * * @param fileName * @param content */ public static void method2(String fileName, String content) &#123; try &#123; // 打开一个写文件器，构造函数中的第二个参数true表示以追加形式写文件 FileWriter writer = new FileWriter(fileName, true); writer.write(content); writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 追加文件：使用RandomAccessFile * * @param fileName * 文件名 * @param content * 追加的内容 */ public static void method3(String fileName, String content) &#123; try &#123; // 打开一个随机访问文件流，按读写方式 RandomAccessFile randomFile = new RandomAccessFile(fileName, \"rw\"); // 文件长度，字节数 long fileLength = randomFile.length(); // 将写文件指针移到文件尾。 randomFile.seek(fileLength); randomFile.writeBytes(content); randomFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; System.out.println(\"start\"); method1(\"c:/test.txt\", \"追加到文件的末尾\"); System.out.println(\"end\"); &#125; &#125;","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.cobsun.com/tags/java/"}]},{"title":"Ubuntu 系统下安装 Cisco AnyConnect VPN","slug":"Ubuntu-系统下安装-Cisco-AnyConnect-VPN","date":"2017-09-13T04:54:48.000Z","updated":"2018-12-21T07:53:15.639Z","comments":true,"path":"2017/09/13/Ubuntu-系统下安装-Cisco-AnyConnect-VPN/","link":"","permalink":"https://www.cobsun.com/2017/09/13/Ubuntu-系统下安装-Cisco-AnyConnect-VPN/","excerpt":"","text":"打算在公司 IDC 机房部署一套VPN环境，经过考虑，最终决定采用 Cisco 下的开源技术 AnyConnect AnyConnect的优势： 长连接，待机不会断开； 速度快，稳定性好； 安全性好，全程加密；另外，支持freeradius认证功能； 能够下发路由表给客户端，这个功能是最激动人心的。因为如果长期连接，那么肯定是某些服务走 VPN，而国内的网站可以走自己的网络体验最好。 耗电量较低； AnyConnect 是思科的安全远程接入解决方案，部署 Anyconnect 需要安装 ocserv(OpenConnect server)， 它是一个OpenConnect SSL协议服务端，0.3.0版后兼容使用AnyConnect SSL 协议的终端。ocserv（OpenConnect Server）是由 GnuTLS 的作者 Nikos Mavrogiannopoulos 开发的一个能够兼容 Cisco Anyconnect 的开源服务端（ SSL VPN），支持*nix/BSD 平台，最早是作为 OpenConnect（Linux下的兼容Cisco ASA的开源客户端）对应的服务端，在后续版本（ 0.3.0 开始）中加入了对 Cisco Anyconnect 客户端的支持。下面介绍在ubuntu系统下安装Anyconnect的操作记录： 安装过程如下（采用一键安装方式）1root@localhost:~# apt-get update &amp;&amp; apt-get upgrade -y root@localhost:~# apt-get install wget root@localhost:~# wget http://git.io/p9r8 --no-check-certificate -O ocservauto.sh //下载地址:https://pan.baidu.com/s/1i59e2hB （提取密码:bp4w） 如果以前使用了该脚本进行安装，只需要输入下面命令更新（只更新相关脚本，服务器不会更新） 123root@localhost:~# wget http://git.io/ocservauto -O- --no-check-certificate|bashroot@localhost:~# bash ocservauto.sh 接着会进行一段时间的安装，如果顺利的话，出现下面信息则说明安装成功了！ 如果安装失败可以查阅安装日志文件ocinstall.log，日志文件在脚本所在文件夹下，可以使用下面命令逐步阅读一般情况下安装成功之后，服务器就在启动状态了。我的部署机器由于是虚拟机(没有外网ip)，采用 squid 代理方式对外访问，导致脚本中定义的 ftp 方式对 freeradius-client-1.1.7.tar.gz 和 ocserv-0.10.8.tar.xz 安装包下载失败。 解决办法：将上面这两个包单独下载下来，放在和ocservauto.sh脚本同一目录路径下，然后再重新执行脚本进行安装 这里可以简单使用本地浏览器查看服务器信息，在本地浏览器输入 https://IP 或域名:（英文冒号）端口 ocserv的默认安装目录是 /etc/ocserv，相关文件都在这个路径下，如配置文件 ocserv.conf 等 1234567891011121314root@localhost:~``# cd /etc/ocserv/root@localhost:``/etc/ocserv``# lsca-cert.pem config-per-group dh.pem ocserv.conf ocserv-up.sh server-cert.pemCAforOC defaults ocpasswd ocserv-down.sh profile.xml server-key.pem ocserv服务在安装后默认就启动了，安装中选择证书登陆方式，即https方式，所以tcp端口选择的是443 12345678root@localhost:~# ps -ef|grep ocservroot 726 1 0 01:22 ? 00:00:00 ocserv-mainroot 728 726 0 01:22 ? 00:00:00 ocserv-secmroot 865 849 0 01:26 pts/1 00:00:00 grep &lt;code--&lt;color=auto ocservroot@localhost:~# lsof -i:443COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEocserv-ma 726 root 4u IPv4 10406026 0t0 TCP *:https (LISTEN)ocserv-ma 726 root 5u IPv6 10406027 0t0 TCP *:https (LISTEN) ocserv服务启动命令：12/etc/init.d/ocserv start/stop/restart/status ocserv服务启动过程中若是出现下面两个小报错：** /usr/sbin/ocserv: error while loading shared libraries: libtspi.so.1: cannot open shared object file:No such file or directory 解决办法： 1root@localhost:~# apt-get install libtspi-dev 2）/usr/sbin/ocserv: error while loading shared libraries: libgnutls.so.28: cannot open shared objectfile: No such file or directory 解决办法： 安装 libgnutls 下载地址：https://pan.baidu.com/s/1skJxpI9提取密码：ic3y 123root@localhost:~# dpkg -i gnutls\\_3.3.8-13\\_amd64.debroot@localhost:~# find / -name libgnutls.so.28/usr/lib64/libgnutls.so.28root@localhost:~# ln -s /usr/lib64/libgnutls.so.28 /usr/lib/ 可以在 ocserv.conf 文件里修改 ocserv 服务端口和域名等信息，修改后重启 ocserv 服务即可12root@localhost:~# /etc/init.d/ocserv restart[ ok ] Restarting ocserv (via systemctl): ocserv.service. Anyconnect 客户端工具下载地址：https://pan.baidu.com/s/1eSvDvEi提取密码：ckdi 安装Anyconnect客户端工具，安装后，就可以使用上面安装ocserv过程中定义的信息连接了： 特别注意：由于安装过程中选择的是自签证书，是不受信任的证书，所以客户端连接时需要关掉设置中的“阻止不信任的服务器”，即下面截图中的第四项 Block connection to untrusted servers不要勾选!不管采不采用证书验证，都不要勾选第四项！。然后勾选第三项（第二项勾选与否都不要紧） 点击“connect”，接着点击提示窗口中点击“Connect Anyway”，接着按照提示输入用户名和密码，正常连接就ok了。 连接成功后，点击右下角的 Anyconnect 标志图，图上有一把钥匙的状态就说明已经连上了。 1）用户名和密码验证（客户端登陆时默认肯定会有的验证方式）12345root@localhost:~# cat /etc/ocserv/ocserv.conf........auth = plain[passwd=/etc/ocserv/ocpasswd] //默认用户名和密码验证enable-auth = certificate //用户名和密码验证同时，允许证书验证auth-timeout = 40 创建用户名和密码命令（或重置用户密码）：12345678910root@localhost:~# ocpasswd -c /etc/ocserv/ocpasswd guohuihuiEnter password:Re-enter password:root@localhost:~# ocpasswd -c /etc/ocserv/ocpasswd liumengnanEnter password:Re-enter password:root@localhost:~# cat /etc/ocserv/ocpasswdwangshibo:*:$5$.GQf1omiKmvGElhU$q1yNyUxPRAHygEGaG98cwVGfYuJjSarsTkXROinhBX8guohuihui:*:$5$z.H5ipnHSJCSigFU$30mseKwk13ZG9MuD3QSeBtYmX6xLOcafVPpioXkulA2liumengnan:*:$5$mVSHMbBekX9vofxV$n7bc8LkJB9kjXl6OADGWySfTqkIBeyIGJRvk5A/ehHC 证书验证除了用户名和密码验证之外，还可以进行证书验证。用户在 AnyConnect 客户端第一次登陆时会提示加载证书。首次登陆加载后，后面再登陆就不会提示加载证书了！所有用户的 p12 证书文件可以在放置脚本的目录下找到，导入证书时需要输入证书创建时设定的密码。 新建用户证书命令：1root@localhost:~# bash ocservauto.sh gc 用户证书创建后会保存到和脚本同一路径下：12root@localhost:~# lshuanqiu.p12 ocinstall.log ocservauto.sh vars_ocservauto 吊销客户证书命令1root@localhost:~# bash ocservauto.sh rc 脚本其他参数说明 查看帮助 1root@localhost:~# bash ocservauto.sh help 平滑升级ocserv（升级后原来的用户数据都会保留） 1root@localhost:~# bash ocservauto.sh ug 强制重装ocserv（注意这样会丢失之前的用户数据和配置）root@localhost:~# bash ocservauto.sh ri 同时开启证书登录和用户名密码登录（请务必首先选择任意一种登录方式来完成安装，接着再使用下面命令） 1234567root@localhost:~# bash ocservauto.sh pc 4. 关于相同客户端证书可以登录多个服务器的方案 假定有三台服务器ABC: ```bash # bash ocservauto.sh rc 吊销所有想要吊销的证书。由于不支持在线吊销证书列表，所以必须还要把A服务器上的/etc/ocserv/crl.pem文件同时复制到BC服务器相同位置，且修改ocserv的配置文件： 1crl = /etc/ocserv/crl.pem 登陆方式在上面一键安装过程中，选择了自签CA，安装后产生pem文件，如下： 1234567891011121314root@localhost:~# cd /etc/ocserv/root@localhost:/etc/ocserv``# ll *.pem-rw-r--r-- 1 root root 1793 Jan 16 23:34 ca-cert.pem-rw-r--r-- 1 root root 1003 Jan 17 02:46 crl.pem-rw-r--r-- 1 root root 2406 Jan 16 23:34 dh.pem-rw-r--r-- 1 root root 3322 Jan 16 23:34 server-cert.pem-rw-r--r-- 1 root root 1675 Jan 16 23:34 server-key.pemroot@localhost:/etc/ocserv# cat ocserv.conf |grep pemserver-cert = /etc/ocserv/server-cert.pemserver-key = /etc/ocserv/server-key.pemdh-params = /etc/ocserv/dh.pemca-cert = /etc/ocserv/ca-cert.pemcrl = /etc/ocserv/crl.pem# http_anchors = FILE:/etc/ocserv-ca.pem 用户名密码登录 -自签CA（证书授权中心），取得ca-cert.pem（不需要保密，类比公钥）和ca-key.pem（需要保密，类比私钥）。 -CA签发信任服务器证书，取得server-cert.pem（不需要保密，类比公钥）、server-key.pem（需要保密，类比私钥）。 -该模式下，密码库是/etc/ocserv/ocpasswd文件。 -如果想使用购买的服务器证书，请参考Nginx服务器证书配置，只需将对应的crt、key 文件重命名为server-cert.pem、server-key.pem，并覆盖到/etc/ocserv/文件夹下面。 证书登录 -自签CA（证书授权中心），取得ca-cert.pem（不需要保密，类比公钥）和ca-key.pem（需要保密，类比私钥）。 -CA签发信任服务器证书，取得server-cert.pem（不需要保密，类比公钥）、server-key.pem（需要保密，类比私钥）。 -CA签发信任客户端证书，最终取得username.p12。 -这里证书授权中心的ca-cert.pem既当作服务器证书的根证书，也当作客户端证书的验证证书。 -由于CA证书当作验证证书，签发客户端证书就需要这个ca-key.pem，可以比同为密码库。 -如果想使用购买的服务器证书，请参考Nginx服务器证书配置（cnblogs.com），只需将对应的 crt、key 文件重命名为 server-cert.pem、server-key.pem，并覆盖到 /etc/ocserv/ 文件夹下面。 改善优化修改的参数都在 /etc/ocserv/ocserv.conf 文件中。a. 对于某些移动宽带、长城带宽等，往往经过了很多重 NAT，容易出现连接成功但是无法打开网页情况，请改小 dpd、mobile-dpd 数值。b. 如果 vps 对于本地延迟甚高，取消注释 output-buffer 项。","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"anyconnect","slug":"anyconnect","permalink":"https://www.cobsun.com/tags/anyconnect/"},{"name":"Linux","slug":"Linux","permalink":"https://www.cobsun.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.cobsun.com/tags/Ubuntu/"},{"name":"VPN","slug":"VPN","permalink":"https://www.cobsun.com/tags/VPN/"}]},{"title":"新鲜出炉一份完整AnyConnect教程！","slug":"e6-96-b0-e9-b2-9c-e5-87-ba-e7-82-89-e4-b8-80-e4-bb-bd-e5-ae-8c-e6-95-b4anyconnect-e6-95-99-e7-a8-8b-ef-bc-81","date":"2017-09-13T04:53:07.000Z","updated":"2018-12-12T09:11:08.950Z","comments":false,"path":"2017/09/13/e6-96-b0-e9-b2-9c-e5-87-ba-e7-82-89-e4-b8-80-e4-bb-bd-e5-ae-8c-e6-95-b4anyconnect-e6-95-99-e7-a8-8b-ef-bc-81/","link":"","permalink":"https://www.cobsun.com/2017/09/13/e6-96-b0-e9-b2-9c-e5-87-ba-e7-82-89-e4-b8-80-e4-bb-bd-e5-ae-8c-e6-95-b4anyconnect-e6-95-99-e7-a8-8b-ef-bc-81/","excerpt":"","text":"一周年零一个月更新： 因为StartCom全家爆炸所以删除了相关的证书内容。 经过测试以后更改了Let’s Encrypt签发证书的内容。 新增了未打开IPv4转发（表现：可以连上服务器但是不能打开网页）的解决方法。 给你们找了一个你们喜欢的一键脚本。 GitHub有一个项目叫Streisand，要是搞不明白的可以尝试一下。自己没测试过。请注意如果**直接编译按照步骤走的话**这个程序似乎是会帮你开新服务器的，我建议参考README.md#running-streisand-on-other-providers来做。 说实话吧，其实我搞AnyConnect搞了好几天，一直碰到一个很鬼畜的Google不到的 getaddrinfo() failed: Name or service not known Cannot listen to specified ports 这个报错…吓得我iptables rule重写了好几遍w 后面再提啦。先走主线。 1. AnyConnect概述简而言之，AnyConnect是Cisco的新一代黑科技。鬼畜的协议可以让它在UDP/TCP之间切换，从而增强稳定性；（和其他VPN相比略微）复杂的部署让非企业用户使用AnyConnect的概率大大降低，基本上只剩下企业用户（这才是关键）。企业用户是什么，是GDP啊（笑）。 更何况今年某大新闻过后，坚挺许久的IPSec和他的小伙伴（PPTP和L2TP）一起见了马克思。 加上AnyConnect提供了独特的证书验证功能（这倒是次要的…反正自签名的证书都会报错根本防不了MITM），所以还是值得各位从各种IPSec啦PPTP啦L2TP啦跑过来的。 2.安装环境准备一贯的，我用的是Debian Jessie，KVM架构。OpenVZ的话…应该也是可以的吧。 2.1 安装依赖包AnyConnect要很多依赖包（喂别跑啊！还没到编译的部分呢）。这些东西可以在后面的README里面找到。Debian和Fedora有所不同，因为我用Debian，所以Fedora的各位就自己去readme里找咯… apt-get install libgnutls28-dev libwrap0-dev libpam0g-dev liblz4-dev libseccomp-dev libreadline-dev libnl-route-3-dev libkrb5-dev build-essential pkg-config gnutls-bin -y development package理论上是用不着的。 2.2 编译ocservocserv就是我们需要的东西了。什么？OpenConnect和AnyConnect不一样？…别急啊。 但是由于官方没有最新版本的固定链接，所以我们得去他们的网站自己扒…看不懂没关系，第一个链接就是了。下载命令格式是： curl -O 下载链接 下载下来以后解压，进入文件夹： tar xvf ocserv*.tar.xz./configuremakemake install 2.3 创建证书AnyConnect需要一个证书来建立安全连接。理论上倒是可以用Let’s Encrypt来给服务器签发证书，但是！LE并不支持针对IP地址签发。如果你在域名中填了IP地址的话就会出现以下错误： Requested name ... is an IP address. The Let’s Encrypt certificate authority will not issue certificates for a bare IP address. 请求的域名...是一个IP地址。Let’s Encrypt证书签发机构将不会对IP地址签发证书。 所以要是你不想买域名的话，还是乖乖用自签名证书吧。反正只要后面把自签名的证书从服务器上导入到本地也是一样的效果。 2.3.1 创建证书模板首先我们得新建一个文件夹，把东西到处乱丢可不是什么好习惯… mkdir certcd certtouch ca.tmplnano ca.tmpl 文本编辑器我用的是nano，各位要是不爽的话也可以用vi，这就不是重点了。总之复制上： cn = “随便填，你开心就好”organization = “同开心就好”serial = 1expiration_days = 365casigning_keycert_signing_keycrl_signing_key 保存退出。 生成密钥和证书。 certtool –generate-privkey –outfile ca-key.pemcerttool –generate-self-signed –load-privkey ca-key.pem –template ca.tmpl –outfile ca-cert.pem 警告：任何东西都不能丢！任何东西都不能丢！任何东西都不能丢！重要的话说三遍 2.3.2 创建服务器证书cn = “这里必须填域名或IP”organization = “同开心就好”expiration_days = 365signing_keyencryption_keytls_www_server 保存。 certtool –generate-privkey –outfile server-key.pem certtool –generate-certificate –load-privkey server-key.pem –load-ca-certificate ca-cert.pem –load-ca-privkey ca-key.pem –template server.tmpl –outfile server-cert.pem certtool –generate-certificate –load-privkey server-key.pem –load-ca-certificate ca-cert.pem –load-ca-privkey ca-key.pem –template server.tmpl –outfile server-cert.pem 然后我们把证书放到一个你喜欢的文件夹，我们假设是/etc/ssl/selfsigned。存放路径可以自己改。 cp ca-cert.pem /etc/ssl/selfsigned/ca-cert.pemcp server-cert.pem /etc/ssl/selfsigned/server-cert.pemcp server-key.pem /etc/ssl/selfsigned/server-key.pem 3.配置ocserv我们在ocserv-x.x.x下操作。 把配置样本复制到/etc/ocserv中进行修改： mkdir ocservcp doc/sample.config /etc/ocserv/ocserv.confnano /etc/ocserv/ocserv.conf 然后添加一个用户名和密码： ocpasswd -c /etc/ocserv/ocpasswd 你喜欢的用户名 接着会让你添加密码，输两遍（一遍用来验证）就行了 找到以下几行（友情提示：nano使用Ctrl+w可以进行搜索）并按照#后面的提示改动（如果你不知道怎么改就不要动了） # 选择喜欢的登录方式，如果想使用证书登录的话应该把auth=”certificate”前的井号删掉并在下面这行的前面加上井号。第5点会提到auth = “plain[/etc/ocserv/ocpasswd]“ # 允许同时连接的总客户端数量，比如下面的4就是最多只能4台设备同时使用max-clients = 4 #不同用户用同一个用户名可以同时登录，下面限制的是多少同名用户可以同时使用。改成0就是不作限制max-same-clients = 2 # ocserv监听的IP地址，千万别动动了就爆炸 #listen-host = [IP|HOSTNAME] # 服务监听的TCP/UDP端口，如果没有搭网站的话就用TCP443/UDP80好了tcp-port = 443udp-port = 80 # 开启以后可以增强VPN性能try-mtu-discovery = true # 让服务器读取用户证书（后面会用到用户证书）cert-user-oid = 2.5.4.3 # 服务器证书与密钥server-cert = /etc/ssl/selfsigned/server-cert.pemserver-key = /etc/ssl/selfsigned/server-key.pem # 服务器所使用的dns，我们使用Google提供的DNSdns = 8.8.8.8dns = 8.8.4.4 #把route = *全注释掉就是了 #route = 192.168.1.0/255.255.255.0 # 使ocserv兼容AnyConnectcisco-client-compat = true # 选择喜欢的登录方式，如果想使用证书登录的话应该把auth=”certificate”前的井号删掉并在下面这行的前面加上井号。第5点会提到auth = “plain[/etc/ocserv/ocpasswd]“ # 允许同时连接的总客户端数量，比如下面的4就是最多只能4台设备同时使用max-clients = 4 #不同用户用同一个用户名可以同时登录，下面限制的是多少同名用户可以同时使用。改成0就是不作限制max-same-clients = 2 # ocserv监听的IP地址，千万别动动了就爆炸 #listen-host = [IP|HOSTNAME] # 服务监听的TCP/UDP端口，如果没有搭网站的话就用TCP443/UDP80好了tcp-port = 443udp-port = 80 # 开启以后可以增强VPN性能try-mtu-discovery = true # 让服务器读取用户证书（后面会用到用户证书）cert-user-oid = 2.5.4.3 # 服务器证书与密钥server-cert = /etc/ssl/selfsigned/server-cert.pemserver-key = /etc/ssl/selfsigned/server-key.pem # 服务器所使用的dns，我们使用Google提供的DNSdns = 8.8.8.8dns = 8.8.4.4 #把route = *全注释掉就是了 #route = 192.168.1.0/255.255.255.0 # 使ocserv兼容AnyConnectcisco-client-compat = true Ctrl+x保存退出。 好了我们来聊聊开头提到的 getaddrinfo() failed。其实只要把listen-host那一行用#注释掉保存就可以了。然后ocserv就会自己进行扫描，多棒啊（ 4.扫尾工作4.1 防火墙设置有些骚年的端口可能被iptables挡住了，现在我们就在iptables上开个洞： iptables -A INPUT -p tcp -m state –state NEW –dport 443 -j ACCEPTiptables -A INPUT -p udp -m state –state NEW –dport 80 -j ACCEPT 然后再开个NAT： iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 顺便说一下有人问“能够正常连接但是上不了网”是什么情况，原因很可能是因为没有开启IPv4转发。IPv4转发的相关参数在/etc/sysctl.conf中，进入后找到net.ipv4.ip_forward=1并把前面的注释（“#”）删掉并保存（保存文件并且sysctl -p）即可。或者也可以使用echo来在文件尾添加上这一参数： echo “net.ipv4.ip_forward=1” &gt;&gt; /etc/sysctl.confsysctl -p 哦对了。看到analytics说有一个“anyconnet不能改端口”的搜索跳转，这里就补充一下：其实把tcp-port和udp-port改掉就好了… 4.2 测试洋洋洒洒写了这么多终于写到了测试，真是泪流满面… ocserv -f -d 1 要是没有报错退出的话，那就可以用了。然而，只是可以用而已。 5.可选操作——添加守护进程（Debian）或使用证书认证5.1 添加守护进程添加守护进程这个是Debian多出来的一步。在CentOS下直接yum install ocserv然后就可以用service ocserv start或者service ocserv stop了。所以其实我新开了一台CentOS服务器，下面的内容是我从其他地方复制的 cd /etc/init.d sudo ln -s /lib/init/upstart-job ocserv cd /etc/init sudo nano ocserv.conf 在新文件中加入以下几行： #!upstartdescription “OpenConnect Server” start on runlevel [2345]stop on runlevel [06] respawnrespawn limit 20 5 scriptexec start-stop-daemon –start –pidfile /var/run/ocserv.pid –exec /usr/local/sbin/ocserv – -f &gt;&gt; /dev/null 2&gt;&amp;1end script 然后Debian党也可以使用service ocserv start/stop了。 补充：CentOS上systemctl start ocserv.service后可能会返回 Job for ocserv.service failed because the control process exited with error code. See “systemctl status ocserv.service” and “journalctl -xe” for details. 这时候敲systemctl status ocserv.service查看上一次的运行过程中发生了什么。一般来说这个日志中会显示配置错误(Syntax error，配置文件中的参数错误，一般会显示执行到第几行)或者是地址已经被使用[bind() failed: Address already in use]。对于第一种情况请检查相关配置文件，对于第二种情况可以lsof -i:ocserv使用的端口 查看端口调用情况。如果看到ocserv-ma则表示已经有一个ocserv服务在运行中，如果没有的话就需要调整到空端口或者手动杀掉占用此端口的进程然后重新启动ocserv。 5.2 客户端使用证书登录既然服务器需要提供证书来验证身份，那么客户端也可以提供身份证书进行登录。那么，我们开始咯我开始感到不耐烦了你们看出来了吗 现在证书推荐使用let’s encrypt生成，具体的方法各位可以参照这一篇文章。用户使用自签名证书作为身份验证凭据的话会因为issuer unknown被拒绝（使用ocserv -f -d 1可以看到debug信息），所以自签名的用户证书是没有用的各位不要再折腾了。 首先我们要回到之前我们创建证书的地方（参见2.3.1），因为路径是阁下选的这里就给不出命令了明明就是偷懒 touch user-cert.tmplnano user-cert.tmpl cn = “随便填”unit = “也是随便填”expiration_days = 365signing_keytls_www_client 生成密钥 certtool –generate-privkey –outfile user-key.pem 生成证书 certtool –generate-certificate –load-privkey user-key.pem –load-ca-certificate ca-cert.pem –load-ca-privkey ca-key.pem –template user-cert.tmpl –outfile user-cert.pem 这里多一步格式转换： certtool –to-p12 –load-privkey user-key.pem –pkcs-cipher 3des-pkcs12 –load-certificate user-cert.pem –outfile user.p12 –outder 然后各位可以把证书弄到自己设备上。怎么弄呢？可以用SFTP/FTP（如：filezilla），也可以直接用Apache/Nginx，本来文章就够长了就不增加各位心理负担了（笑 最后回去编辑/etc/ocserv/ocserv.conf，把auth = “plain[/etc/ocserv/ocpasswd]”用 # 注释掉，把auth = “certificate” 的注释删除，注释掉 listen-clear-file = /var/run/ocserv-conn.socket，把ca-cert = 改成下面的 ca-cert = /etc/ssl/selfsigned/ca-cert.pem ，重启服务，大功告成！","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"anyconnect","slug":"anyconnect","permalink":"https://www.cobsun.com/tags/anyconnect/"},{"name":"cisco","slug":"cisco","permalink":"https://www.cobsun.com/tags/cisco/"}]},{"title":"详解https是如何确保安全的？","slug":"e8-af-a6-e8-a7-a3https-e6-98-af-e5-a6-82-e4-bd-95-e7-a1-ae-e4-bf-9d-e5-ae-89-e5-85-a8-e7-9a-84-ef-bc-9f","date":"2017-08-26T03:07:18.000Z","updated":"2018-12-12T09:13:19.487Z","comments":false,"path":"2017/08/26/e8-af-a6-e8-a7-a3https-e6-98-af-e5-a6-82-e4-bd-95-e7-a1-ae-e4-bf-9d-e5-ae-89-e5-85-a8-e7-9a-84-ef-bc-9f/","link":"","permalink":"https://www.cobsun.com/2017/08/26/e8-af-a6-e8-a7-a3https-e6-98-af-e5-a6-82-e4-bd-95-e7-a1-ae-e4-bf-9d-e5-ae-89-e5-85-a8-e7-9a-84-ef-bc-9f/","excerpt":"","text":"Https 介绍什么是HttpsHTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL Https的作用 内容加密 建立一个信息安全通道，来保证数据传输的安全； 身份认证 确认网站的真实性 数据完整性 防止内容被第三方冒充或者篡改 Https的劣势 对数据进行加解密决定了它比http慢 需要进行非对称的加解密，且需要三次握手。首次连接比较慢点，当然现在也有很多的优化。 出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。Firefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。 IE只要http头允许就可以缓存https内容，缓存策略与是否使用HTTPS协议无关。 HTTPS和HTTP的区别 https协议需要到CA申请证书。 http是超文本传输协议，信息是明文传输；https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 http默认使用80端口，https默认使用443端口 下面就是https的整个架构，现在的https基本都使用TLS了，因为更加安全，所以下图中的SSL应该换为SSL/TLS。 下面就上图中的知识点进行一个大概的介绍。 加解密相关知识对称加密对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。常见的对称加密有：DES（Data Encryption Standard）、AES（Advanced Encryption Standard）、RC4、IDEA 非对称加密与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）；并且加密密钥和解密密钥是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。 非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是 2048 位，意味着待加密内容不能超过 256 个字节。 摘要算法数字摘要是采用单项Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文，这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。“数字摘要“是https能确保数据完整性和防篡改的根本原因。 数字签名数字签名技术就是对“非对称密钥加解密”和“数字摘要“两项技术的应用，它将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。数字签名的过程如下：明文 --&gt; hash运算 --&gt; 摘要 --&gt; 私钥加密 --&gt; 数字签名 数字签名有两种功效：一、能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。二、数字签名能确定消息的完整性。 注意： 数字签名只能验证数据的完整性，数据本身是否加密不属于数字签名的控制范围 数字证书为什么要有数字证书？对于请求方来说，它怎么能确定它所得到的公钥一定是从目标主机那里发布的，而且没有被篡改过呢？亦或者请求的目标主机本本身就从事窃取用户信息的不正当行为呢？这时候，我们需要有一个权威的值得信赖的第三方机构(一般是由政府审核并授权的机构)来统一对外发放主机机构的公钥，只要请求方这种机构获取公钥，就避免了上述问题的发生。 数字证书的颁发过程用户首先产生自己的密钥对，并将公共密钥及部分个人身份信息传送给认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内包含用户的个人信息和他的公钥信息，同时还附有认证中心的签名信息(根证书私钥签名)。用户就可以使用自己的数字证书进行相关的各种活动。数字证书由独立的证书发行机构发布，数字证书各不相同，每种证书可提供不同级别的可信度。 证书包含哪些内容 证书颁发机构的名称 证书本身的数字签名 证书持有者公钥 证书签名用到的Hash算法 验证证书的有效性浏览器默认都会内置CA根证书，其中根证书包含了CA的公钥 证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书 证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。用CA的公钥，对伪造的证书的摘要进行解密，发现解不了，认为是危险证书。 对于篡改的证书，使用CA的公钥对数字签名进行解密得到摘要A，然后再根据签名的Hash算法计算出证书的摘要B，对比A与B，若相等则正常，若不相等则是被篡改过的。 证书可在其过期前被吊销，通常情况是该证书的私钥已经失密。较新的浏览器如Chrome、Firefox、Opera和Internet Explorer都实现了在线证书状态协议（OCSP）以排除这种情形：浏览器将网站提供的证书的序列号通过OCSP发送给证书颁发机构，后者会告诉浏览器证书是否还是有效的。 1、2点是对伪造证书进行的，3是对于篡改后的证书验证，4是对于过期失效的验证。 SSL 与 TLSSSL (Secure Socket Layer，安全套接字层)SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取，当前为3.0版本。 SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 TLS (Transport Layer Security，传输层安全协议)用于两个应用程序之间提供保密性和数据完整性。TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。 SSL/TLS协议作用： 认证用户和服务器，确保数据发送到正确的客户机和服务器； 加密数据以防止数据中途被窃取； 维护数据的完整性，确保数据在传输过程中不被改变。 TLS比SSL的优势 对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。 增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。 改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。 一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。 特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。 SSL、TLS的握手过程SSL与TLS握手整个过程如下图所示，下面会详细介绍每一步的具体内容： 客户端首次发出请求由于客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在TLS协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，这个随机数一方面需要在客户端保存，另一方面需要传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的 Master Secret 。 客户端需要提供如下信息： 支持的协议版本，比如TLS 1.0版 一个客户端生成的随机数，稍后用于生成”对话密钥” 支持的加密方法，比如RSA公钥加密 支持的压缩方法 服务端首次回应服务端在接收到客户端的Client Hello之后，服务端需要确定加密协议的版本，以及加密的算法，然后也生成一个随机数，以及将自己的证书发送给客户端一并发送给客户端，这里的随机数是整个过程的第二个随机数。 服务端需要提供的信息： 协议的版本 加密的算法 随机数 服务器证书 客户端再次回应客户端首先会对服务器下发的证书进行验证，验证通过之后，则会继续下面的操作，客户端再次产生一个随机数（第三个随机数），然后使用服务器证书中的公钥进行加密，以及放一个ChangeCipherSpec消息即编码改变的消息，还有整个前面所有消息的hash值，进行服务器验证，然后用新秘钥加密一段数据一并发送到服务器，确保正式通信前无误。客户端使用前面的两个随机数以及刚刚新生成的新随机数，使用与服务器确定的加密算法，生成一个Session Secret。 ChangeCipherSpecChangeCipherSpec是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了。 服务器再次响应服务端在接收到客户端传过来的第三个随机数的 加密数据之后，使用私钥对这段加密数据进行解密，并对数据进行验证，也会使用跟客户端同样的方式生成秘钥，一切准备好之后，也会给客户端发送一个 ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了。之后，服务端也会使用 Session Secret 加密一段 Finish 消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。 后续客户端与服务器间通信确定秘钥之后，服务器与客户端之间就会通过商定的秘钥加密消息了，进行通讯了。整个握手过程也就基本完成了。 值得特别提出的是：SSL协议在握手阶段使用的是非对称加密，在传输阶段使用的是对称加密，也就是说在SSL上传送的数据是使用对称密钥加密的！因为非对称加密的速度缓慢，耗费资源。其实当客户端和主机使用非对称加密方式建立连接后，客户端和主机已经决定好了在传输过程使用的对称加密算法和关键的对称加密密钥，由于这个过程本身是安全可靠的，也即对称加密密钥是不可能被窃取盗用的，因此，保证了在传输过程中对数据进行对称加密也是安全可靠的，因为除了客户端和主机之外，不可能有第三方窃取并解密出对称加密密钥！如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。 其他补充对于非常重要的保密数据，服务端还需要对客户端进行验证，以保证数据传送给了安全的合法的客户端。服务端可以向客户端发出 Cerficate Request 消息，要求客户端发送证书对客户端的合法性进行验证。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。 PreMaster secret前两个字节是TLS的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在Client Hello阶段，客户端会发送一份加密套件列表和当前支持的SSL/TLS的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。所以，服务端需要对密文中解密出来对的PreMaster版本号跟之前Client Hello阶段的版本号进行对比，如果版本号变低，则说明被串改，则立即停止发送任何消息。 session的恢复有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。 session IDsession ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。 session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话 session ticket客户端发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。 目前只有Firefox和Chrome浏览器支持。 总结https实际就是在TCP层与http层之间加入了SSL/TLS来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。 参考文章数字证书的基础知识HTTPS科普扫盲帖和安全有关的那些事OpenSSL 与 SSL 数字证书概念贴基于OpenSSL自建CA和颁发SSL证书聊聊HTTPS和SSL/TLS协议SSL/TLS协议运行机制的概述图解SSL/TLS协议大型网站的 HTTPS 实践SSL/TLS原理详解扒一扒HTTPS网站的内幕白话解释 OSI模型，TLS/SSL 及 HTTPSOpenSSL HeartBleed漏洞原理漫画图解","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[]},{"title":"在Opensuse Leap上部署Ocserv（Anyconnect） | VPN信息网","slug":"e5-9c-a8opensuse-leap-e4-b8-8a-e9-83-a8-e7-bd-b2ocserv-ef-bc-88anyconnect-ef-bc-89-vpn-e4-bf-a1-e6-81-af-e7-bd-91","date":"2017-08-26T02:34:41.000Z","updated":"2018-12-12T09:08:58.681Z","comments":false,"path":"2017/08/26/e5-9c-a8opensuse-leap-e4-b8-8a-e9-83-a8-e7-bd-b2ocserv-ef-bc-88anyconnect-ef-bc-89-vpn-e4-bf-a1-e6-81-af-e7-bd-91/","link":"","permalink":"https://www.cobsun.com/2017/08/26/e5-9c-a8opensuse-leap-e4-b8-8a-e9-83-a8-e7-bd-b2ocserv-ef-bc-88anyconnect-ef-bc-89-vpn-e4-bf-a1-e6-81-af-e7-bd-91/","excerpt":"","text":"Opensuse的Wiki中介绍了Ocserv的搭建。 由于良久没有更新，文中的方法已经部分失效，因此在此对wiki中失效的方法作出修改。本文部署基于Leap 42.3，部分内容引用Opensuse的wiki。 背景知识：什么是 Cisco Anyconnect？什么是 ocserv？Cisco Anyconnect 是思科推出的一款企业级 VPN。其背后的开源技术是OpenConnect。简单来说就是平时使用 UDP 的DTLS协议进行加密，掉线时自动使用 TCP 的 TLS 协议进行备份恢复，因此相对其它 VPN 比较稳定；而且广泛被大企业采用，不容易被误杀；而加之比较小众架设起来不太容易，也吸引不了很多的火力。 ocserv 的安装ocserv已经包括在了Opensue的官方源中，因此ocserv的安装十分简单，只需要一条命令 linux# zypper in ocserv ocserv 的初始化配置修改 server.tmpl 模板将 ocserv 安装到您的服务器上后，您需要编辑 /etc/ocserv/certificates/server.tmpl，将其中的： cn = &quot;Your hostname or IP&quot; 改成你服务器的 IP 地址，可以使用： linux# ifconfig -a 查看您的ip地址 生成证书linux# cd /etc/ocserv/certificates linux# certtool --generate-privkey --outfile ca-key.pem linux# certtool --generate-self-signed --load-privkey ca-key.pem --template ca.tmpl --outfile ca-cert.pem linux# certtool --generate-privkey --outfile server-key.pem linux# certtool --generate-certificate --load-privkey server-key.pem --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem --template server.tmpl --outfile server-cert.pem 参考：http://blog.tremily.us/posts/X.509_certificates/ 如果你有购买的SSL证书，只需要生成ca-key.pem即可，然后将你的证书和私钥放在/etc/ocserv/certificates下即可 生成密码文件linux# ocpasswd -c /etc/ocserv/ocpasswd 您要使用的用户名 “您要使用的用户名“是随意的，之后会提示您输入两次密码。 配置防火墙客户端连上Ocserv后使用的 IP 地址段 192.168.1.0/24 是可以在 /etc/ocserv/ocserv.conf 中配置的，这里用的是默认的。 同样，客户端连接Ocserv时使用的端口也是可以在 /etc/ocserv/ocserv.conf 中配置的，这里用的是tcp 999与udp 1999。 注意: 如果您没有特别设置过，新版 udev 确定的网口可能不是规整的 eth0，您需要 ifconfig -a 看后替换成你的。 使用SuSEfirewall2修改/etc/sysconfig/SuSEfirewall2 FW_DEV_INT=&quot;vpns0&quot; FW_ROUTE=&quot;yes&quot; FW_MASQUERADE=&quot;yes&quot; FW_MASQ_NETS=&quot;192.168.1.0/24&quot; FW_SERVICES_EXT_TCP=&quot;80 999 8080&quot; FW_SERVICES_EXT_UDP=&quot;1999&quot; FW_FORWARD=&quot;192.168.1.0/24,0/0&quot; 之后重新启动防火墙使之生效 linux# rcSuSEfirewall2 restart 使用iptables如果你习惯使用iptales，你需要在先关闭SuSEfirewall2 linux# systemctl disable SuSEfirewall2 linux# systemctl stop SuSEfirewall2 设置iptables转发规则 linux# echo 1 &gt; /proc/sys/net/ipv4/ip_forward linux# iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j MASQUERADE linux# iptables -A FORWARD -s 192.168.1.0/24 -j ACCEPT 测试linux# ocserv -f -d 1 运行不报错的话，可以用客户端连接来测试一下。 启动服务linux# ocserv -f -c /etc/ocserv/ocserv.conf 客户端证书登录也可以使用客户端证书而不是用户名密码来登录。 linux# certtool --generate-privkey --outfile user-key.pem linux# certtool --generate-certificate --load-privkey user-key.pem --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem --template user.tmpl --outfile user-cert.pem 生成 iOS 可用的 pk12 文件linux# openssl pkcs12 -export -inkey user-key.pem -in user-cert.pem -certfile ca-cert.pem -out user.p12 会提示设置密码。之后可以把 user.p12 放在可以在线下载的地方，用你的 safari 去打开那个 URL 导入证书。 修改 ocserv.conf 配置把 auth 由 #auth = &quot;certificate&quot; auth = &quot;plain[/etc/ocserv/ocpasswd]&quot; 变成 auth = &quot;certificate&quot; #auth = &quot;plain[/etc/ocserv/ocpasswd]&quot; 并注释掉不支持的选项： listen-clear-file = /var/run/ocserv-conn.socket 然后启用证书验证 ca-cert = /etc/ocserv/certificates/ca-cert.pem 然后重新启动 ocserv.service linux# systemctl restart ocserv","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"anyconnect","slug":"anyconnect","permalink":"https://www.cobsun.com/tags/anyconnect/"},{"name":"cisco","slug":"cisco","permalink":"https://www.cobsun.com/tags/cisco/"},{"name":"vpn","slug":"vpn","permalink":"https://www.cobsun.com/tags/vpn/"}]},{"title":"mysql默认时间日期","slug":"874","date":"2017-08-16T05:26:29.000Z","updated":"2018-12-12T08:57:54.157Z","comments":true,"path":"2017/08/16/874/","link":"","permalink":"https://www.cobsun.com/2017/08/16/874/","excerpt":"","text":"MySQL设置当前时间为默认值的问题我们经常会遇到，下面就为您介绍MySQL设置当前时间为默认值的实现全步骤，希望对您能有所启迪。 数据库：test_db1 创建表：test_ta1 两个字段： id （自增 且为主键）， createtime 创建日期（默认值为当前时间） – mysql默认时间日期use test_db1; create table test_ta1( id mediumint(8) unsigned not nulll auto_increment, createtime timestamp not null default current_timestamp, primary key (id)","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.cobsun.com/categories/数据库/"}],"tags":[{"name":"date","slug":"date","permalink":"https://www.cobsun.com/tags/date/"},{"name":"mysql","slug":"mysql","permalink":"https://www.cobsun.com/tags/mysql/"},{"name":"time","slug":"time","permalink":"https://www.cobsun.com/tags/time/"},{"name":"timestamp","slug":"timestamp","permalink":"https://www.cobsun.com/tags/timestamp/"},{"name":"日期时间","slug":"日期时间","permalink":"https://www.cobsun.com/tags/日期时间/"}]},{"title":"[转]深入理解双因子认证","slug":"e8-bd-ac-e6-b7-b1-e5-85-a5-e7-90-86-e8-a7-a3-e5-8f-8c-e5-9b-a0-e5-ad-90-e8-ae-a4-e8-af-81","date":"2017-08-06T07:10:02.000Z","updated":"2018-12-12T09:13:19.508Z","comments":true,"path":"2017/08/06/e8-bd-ac-e6-b7-b1-e5-85-a5-e7-90-86-e8-a7-a3-e5-8f-8c-e5-9b-a0-e5-ad-90-e8-ae-a4-e8-af-81/","link":"","permalink":"https://www.cobsun.com/2017/08/06/e8-bd-ac-e6-b7-b1-e5-85-a5-e7-90-86-e8-a7-a3-e5-8f-8c-e5-9b-a0-e5-ad-90-e8-ae-a4-e8-af-81/","excerpt":"","text":"关于两步验证，写的非常好的一篇文章。 来源： [Debug Hacks](http://blog.gaoyuan.xyz/2017/01/05/2fa-a-programmers-perspective/) 去年年初，让ops在服务器上开启了基于google-authenticator的双因子认证。最近花了点时间进行深入了解，记录如下。 双因子认证的相关概念双因子认证（Two-factor authentication，也叫2FA），是一种通过组合两种不同的验证方式进行用户身份验证的机制。Google在2011年3月份，宣布在线上使用双因子认证，MSN和Yahoo紧随其后。 双因子认证，除了需要验证用户名密码外，还要结合另外一种实物设备，如Rsa令牌，或者手机。 如果我们把传统的用户名密码验证称为单因子认证（1FA），那么对比双因子认证（2FA），他们的区别如下： 1FA – What you know (e.g. a password, a pin) 2FA – What you have (e.g. a phone, a hardware token) 3FA – What you are (e.g. your fingerprints, you retina) 双因子认证的产品大致可以分成两类： 可以产生token的硬件设备 智能手机的app 手机短信验证码，登录微信公众号时的扫码确认都可以称为双因子认证。 双因子认证，还会结合一个只有你有的硬件设备。只要这个专属的硬件设备不丢失（察觉这个设备丢失，比用户名密码泄露，会容易很多），就可以大大地提升账号的安全性。 双因子认证的实现[caption id=”” align=”alignleft” width=”1214”] Two-factor authentication flow[/caption] 双因子认证的流程如下： 认证过程中涉及的token，一般会使用一次性密码(One-time password)，相关实现有： HOTP: 基于次数的一次性密码（HMAC-Based One-Time Password） TOTP: 基于时间的一次性密码（Time-Based One-Time Password） HOTP和TOTP的实现都基于HMAC-SHA-1算法。 HOTP的生成算法如下 HOTP(K,C) = Truncate(HMAC-SHA-1(K,C)) 其中： C是一个8-byte的自增变量。对于客户端，每生成一次性密码，其值加1。对于服务端，每次成功认证客户端产生的一次性密码，其值加1。在HOTP生成（客户端）和验证（服务端）过程中，C的值必须同步。 K是客户端和服务端使用的共享密钥，每个客户端的K应该都是唯一的。 生成步骤如下： Step 1: 使用HMAC-SHA-1算法，利用C和K，生成一个长度为20-byte的40个十六进制字符，即：HS = HMAC-SHA-1(K,C) Step 2: 根据前面产品的字符串`HS`，生成一个长度为4-byte的8个十六进制字符，即：Sbits = DT(HS)，DT是根据HS，动态产生Sbits的方法，后面的示例中会提到 Step 3: 根据前面的Sbits，计算一个HOTP的值，一般为6位数字。 2 nibbles (2 hex characters) = 1-byte TOTP可以当做是HOTP算法的一个变种，可以将TOTP的生成算法定义为： TOTP = HOTP(K, T) K同HOTP算法中K的定义，是客户端和服务端使用的共享密钥，T是一个整数，定义如下： T = floor((Current Unix time - T0) / X) 其中： T0是起始的Unix Time，默认为0 X是T增长的步长，默认为30 即T是以30为步长，当前的Unix Time距初始的Unix TimeT0增长的数量。 如果T0=0，X=30，那么当此刻的Unix time是59时，T=1，当此刻的Unix time为60时，T=2。TOTP算法生成的一次性密码，就会每30s变更一次。 一次性密码的生成过程本文以HMAC-SHA-1算法生成的字符串HS的值是0215a7d8c15b492e21116482b6d34fc4e1a9f6ba为例，介绍一次性密码的生成过程。 如果使用TOTP算法进行双因子认证，要让用户在30s内输入40个十六进制的字符，这是一件很难想象的事情。所以我们需要想个办法，将HS转换地更加便于输入，而又不失安全性。这就是前面提到的DT（Dynamic Truncation）的处理过程。 为了更清晰地展示生成过程，用下图表示HS： 前面的图中包含40个字符，每个字符都占4-bits（有16个可能的值0-15），被分成了20组单独的字符串。 我们先去找HS的低4位（最后一个字符），作为截取字符串的起始位置。在我们的例子里，最后一个字符是a： 将十六进制的字符a转成十进制数是10。 我们将第1组字符串的偏移量用0表示，以此类推，如下： 然后，从字符串HS的第10个偏移量开始，截取4组字符串（或者是接下来的31-bits）。 这样截取的最大偏移量是15+4=19，刚好没有越界 因此，我们通过DT（Dynamic Truncation）处理，将HS转换后得到的字符串是6482b6d3： 将十六进制的6482b6d3转成十进制数是1686288083。 因为我们需要一个6位的数字，所以和1000000进行取模运算： 1686288083 modulo 1000000 最后的结果是： 288083 使用google-authenticator，开启服务器双因子认证首先，去你喜欢的android应用市场，或者apple的appStore去安装：“Google Authenticator（google身份验证器）”。 然后登录要开启双因子认证登录的服务器，进行下面的操作。 安装依赖 yum -y install gcc gcc-c++ make wget pam-devel 安装Google Authenticator wget http://google-authenticator.googlecode.com/files/libpam-google-authenticator-1.0-source.tar.bz2 tar jxvf libpam-google-authenticator-1.0-source.tar.bz2 cd libpam-google-authenticator-1.0 make sudo make install 配置SSH登录时调用google-authenticator模块 编辑文件/etc/pam.d/sshd，添加： auth required pam_google_authenticator.so 编辑文件/etc/ssh/sshd_config，在文件中查找ChallengeResponseAuthentication和UsePAM，修改为如下内容： ChallengeResponseAuthentication yes UsePAM yes 重启ssh sudo service ssh restart 下面是配置Google Authenticator的相关步骤。 如果要为用户zhangsan添加ssh登录时的双因子认证，执行如下命令： 12 su - zhangsan google-authenticator 会出现一串问题，让你选y或者n。 Do you want authentication tokens to be time-based (y/n) y https://www.google.com/chart?chs=200x200&amp;chld=M|0&amp;cht=qr&amp;chl=otpauth://totp/zhangsan@ali%3Fsecret%3DWKHM6UVJNTPYSPTQ Your new secret key is: WKHM6UVJNTPYSPTQ Your verification code is 434260 Your emergency scratch codes are: 30287010 70585905 68748337 15176712 38041521 上面的这一步，会生成一个base32编码的共享密钥WKHM6UVJNTPYSPTQ，即前面的K，用于在客户端进行绑定（如果可以翻墙的话，实际上会看到一张二维码，使用Google Authenticator app扫码即可以完成绑定）。 共享密钥使用base32而非base64的原因如下： base32编码的字符串，包含了大写英文字母和数字2-7。不会因字体显示问题，把1，8，0和’I’,‘B’, ‘O’混淆，更利于输入。 base32编码的字符串，出现在url中时，可以不用进行url编码处理（encode），便于直接使用生成二维码的web服务。 同时，基于当前的Unix time，生成了一个动态验证码434260，可用于测试。并生成了5个应急备用验证码（上面的emergency scratch codes），可以在绑定设备丢失的情况下使用（每个应急码只能使用一次）。 剩下的问题，没有特殊癖好，可以都选y。 Do you want me to update your &quot;/home/zhangsan/.google_authenticator&quot; file (y/n) y Do you want to disallow multiple uses of the same authentication token? This restricts you to one login about every 30s, but it increases your chances to notice or even prevent man-in-the-middle attacks (y/n) y By default, tokens are good for 30 seconds and in order to compensate for possible time-skew between the client and the server, we allow an extra token before and after the current time. If you experience problems with poor time synchronization, you can increase the window from its default size of 1:30min to about 4min. Do you want to do so (y/n) y If the computer that you are logging into isn&apos;t hardened against brute-force login attempts, you can enable rate-limiting for the authentication module. By default, this limits attackers to no more than 3 login attempts every 30s. Do you want to enable rate-limiting (y/n) y 之后，ssh登录服务器时，会看到类似这样的提示： verification code: 这时，打开手机上的google身份验证器App，输入对应的code，如下： reference： [^1] https://pthree.org/2014/04/15/time-based-one-time-passwords-how-it-works/ [^2] https://garbagecollected.org/2014/09/14/how-google-authenticator-works/ [^3] https://www.blackmoreops.com/2014/06/26/securing-ssh-two-factor-authentication-using-google-authenticator/","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"google","slug":"google","permalink":"https://www.cobsun.com/tags/google/"},{"name":"Two-factor authentication","slug":"Two-factor-authentication","permalink":"https://www.cobsun.com/tags/Two-factor-authentication/"},{"name":"两步验证","slug":"两步验证","permalink":"https://www.cobsun.com/tags/两步验证/"}]},{"title":"德兰修女 箴言","slug":"e5-be-b7-e5-85-b0-e4-bf-ae-e5-a5-b3-e7-ae-b4-e8-a8-80","date":"2017-08-06T05:49:19.000Z","updated":"2018-12-12T09:08:58.799Z","comments":true,"path":"2017/08/06/e5-be-b7-e5-85-b0-e4-bf-ae-e5-a5-b3-e7-ae-b4-e8-a8-80/","link":"","permalink":"https://www.cobsun.com/2017/08/06/e5-be-b7-e5-85-b0-e4-bf-ae-e5-a5-b3-e7-ae-b4-e8-a8-80/","excerpt":"","text":"人们经常是不讲道理的、没有逻辑的和以自我为中心的 不管怎样，你要原谅他们 即使你是友善的，人们可能还是会说你自私和动机不良 不管怎样，你还是要友善 当你功成名就，你会有一些虚假的朋友 和一些真实的敌人 不管怎样，你还是要取得成功 即使你是诚实的和率直的，人们可能还是会欺骗你 不管怎样，你还是要诚实和率直 你多年来营造的东西 有人在一夜之间把它摧毁 不管怎样，你还是要去营造 如果你找到了平静和幸福，他们可能会嫉妒你 不管怎样，你还是要快乐 你今天做的善事，人们往往明天就会忘记 不管怎样，你还是要做善事 即使把你最好的东西给了这个世界 也许这些东西永远都不够 不管怎样，把你最好的东西给这个世界 你看，说到底，它是你和上帝之间的事 而决不是你和他人之间的事","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"德兰修女","slug":"德兰修女","permalink":"https://www.cobsun.com/tags/德兰修女/"},{"name":"箴言","slug":"箴言","permalink":"https://www.cobsun.com/tags/箴言/"}]},{"title":"使用screen命令长期执行远程命令","slug":"e4-bd-bf-e7-94-a8screen-e5-91-bd-e4-bb-a4-e9-95-bf-e6-9c-9f-e6-89-a7-e8-a1-8c-e8-bf-9c-e7-a8-8b-e5-91-bd-e4-bb-a4","date":"2017-07-19T07:41:25.000Z","updated":"2018-12-12T09:05:36.324Z","comments":true,"path":"2017/07/19/e4-bd-bf-e7-94-a8screen-e5-91-bd-e4-bb-a4-e9-95-bf-e6-9c-9f-e6-89-a7-e8-a1-8c-e8-bf-9c-e7-a8-8b-e5-91-bd-e4-bb-a4/","link":"","permalink":"https://www.cobsun.com/2017/07/19/e4-bd-bf-e7-94-a8screen-e5-91-bd-e4-bb-a4-e9-95-bf-e6-9c-9f-e6-89-a7-e8-a1-8c-e8-bf-9c-e7-a8-8b-e5-91-bd-e4-bb-a4/","excerpt":"","text":"使用 screen 命令长期执行远程命令经常需要登录到 linux 里执行一些长时间运行的命令， 后台执行的方法有很多，包括 nhup &amp; 等等 但是这些不支持全部的功能，比如我执行一个命令，需要在开始时接受用户输入，比如 密码、是否确认执行 这个时候比较适合用 screen 最常用的命令： 开启一个名为 task1 的 screen：screen -S task1 这时可以看到终端闪了一下，然后屏幕变成干干净净的了，其实标题行还显示着 screen 0 ×××× 等信息 即表示已经进入了screen的 Session 中了 然后就可以在这里执行任意的命令，和普通终端一模一样， 如果执行了一个需要很久才能结束的命令 ，又怕中途 SSH 断掉而中断命令， 可以在screen 窗口直接按键： Ctrl+a d ↑ 让 screen 进入 Detached 模式（将任务（Session）转移到后台） 当你需要再次进入screen以查看刚刚的命令执行的怎么样了， 可以先 list 一下： screen -ls 现在会显示出所有正在执行的命令，比如 [root@SJHL199-29 ~]# screen -ls There is a screen on: 32353.task1 (Detached) 1 Socket in /var/run/screen/S-root. 然后使用 screen -r 32353 ↑进入刚才执行的命令/session中使用 Ctrl + d 可以终止当前窗口 常用的 screen 命令 按键方式 意义 C-a ? 显示所有键绑定信息 C-a w 显示所有窗口列表 C-a C-a 切换到之前显示的窗口 C-a c 创建一个新的运行shell的窗口并切换到该窗口 C-a n 切换到下一个窗口 C-a p 切换到前一个窗口(与C-a n相对) C-a 0..9 切换到窗口0..9 C-a a 发送 C-a到当前窗口 C-a d 暂时断开screen会话 C-a k 杀掉当前窗口 C-a [ 进入拷贝/回滚模式","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.cobsun.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.cobsun.com/tags/linux/"},{"name":"screen","slug":"screen","permalink":"https://www.cobsun.com/tags/screen/"},{"name":"ssh","slug":"ssh","permalink":"https://www.cobsun.com/tags/ssh/"},{"name":"后台","slug":"后台","permalink":"https://www.cobsun.com/tags/后台/"}]},{"title":"解决lxde桌面环境下Google-Chrome不在菜单中显示的问题","slug":"resolve-chrome-not-appear-in-menus-under-lxde","date":"2017-07-10T07:09:18.000Z","updated":"2018-12-18T08:28:52.783Z","comments":true,"path":"2017/07/10/resolve-chrome-not-appear-in-menus-under-lxde/","link":"","permalink":"https://www.cobsun.com/2017/07/10/resolve-chrome-not-appear-in-menus-under-lxde/","excerpt":"","text":"用的是 Debian8.x LXDE 环境， 装好了Google Chrome，重启。然后发现菜单中并没有出现熟悉的 Chrome 应用，并且在 网络/互联网 选项中也没有 Google 的身影 解决办法： 先看看当前登录用户的目录下有没有chrome的menu文件， 比如，我下面的截图显示的 是 mslagee 这个用户的目录中存在的 chrome 的配置 然后将 user-chrome-apps.menu 配置文件拷贝至 /etc/xdg/menus 目录 系统菜单立刻就能看到 Chrome 的身影了","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.cobsun.com/tags/linux/"},{"name":"google","slug":"google","permalink":"https://www.cobsun.com/tags/google/"},{"name":"chrome","slug":"chrome","permalink":"https://www.cobsun.com/tags/chrome/"},{"name":"lxde","slug":"lxde","permalink":"https://www.cobsun.com/tags/lxde/"}]},{"title":"在 Debian 下安装 WordPress","slug":"745","date":"2017-07-04T06:44:42.000Z","updated":"2018-12-12T08:57:54.157Z","comments":true,"path":"2017/07/04/745/","link":"","permalink":"https://www.cobsun.com/2017/07/04/745/","excerpt":"","text":"Basic Installation guide for Wheezy# apt-get install wordpress curl apache2 mysql-server Set the mysql admin root user password when prompted Create a site# nano /etc/apache2/sites-available/wp.conf Add this content: Alias /wp/wp-content /var/lib/wordpress/wp-content Alias /wp /usr/share/wordpress &lt;Directory /usr/share/wordpress&gt; Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Order allow,deny Allow from all &lt;/Directory&gt; &lt;Directory /var/lib/wordpress/wp-content&gt; Options FollowSymLinks Order allow,deny Allow from all &lt;/Directory&gt; For Apache 2.4 (Jessie) you’ll need a slightly different site configuration: # nano /etc/apache2/sites-available/wp.conf add this content: Alias /wp/wp-content /var/lib/wordpress/wp-content Alias /wp /usr/share/wordpress &lt;Directory /usr/share/wordpress&gt; Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted &lt;/Directory&gt; &lt;Directory /var/lib/wordpress/wp-content&gt; Options FollowSymLinks Require all granted &lt;/Directory&gt; Enable the site# a2ensite wp Restart the webserver # service apache2 reload Create /etc/wordpress/config-$DM.php. $DM is the domain name e.g. if the fully qualified domain name is www.debianwordpress.dev, create one of the following files: /etc/wordpress/config-www.debianwordpress.dev.php (this is the default, use it if you are unsure) /etc/wordpress/config-debianwordpress.dev.php (this is used for multisite with subdomains) /etc/wordpress/config-default.php (this is used as a fallback if no other file matches your domain name) WordPress searches in the above order and uses the first configuration file it can find. The domain name is taken from the HTTP-Request of your browser. That way you may be able to define different configuration files for different domains you are hosting. # nano /etc/wordpress/config-www.debianwordpress.dev.php Add this content:- &lt;?php define(‘DB_NAME’, ‘wordpress’); define(‘DB_USER’, ‘wordpress’); define(‘DB_PASSWORD’, ‘password’); define(‘DB_HOST’, ‘localhost’); define(‘WP_CONTENT_DIR’, ‘/var/lib/wordpress/wp-content’); ?&gt; replace password with a suitably secure password Create a file to hold the database creation instructions # nano ~/wp.sql Add this content:- CREATE DATABASE wordpress;GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTERON wordpress.*TO wordpress@localhostIDENTIFIED BY ‘password’;FLUSH PRIVILEGES; replace password with your “suitably secure password” Create the database:- # cat ~/wp.sql | mysql –defaults-extra-file=/etc/mysql/debian.cnf Navigate to the wordpress directory in browser e.g.:- http://debianwordpress.dev/wp which redirects to http://debianwordpress.dev/wp/wp-admin/install.php where you’ll see the “classic” wordpress 5 minute install page (actually a 5 second install thanks to the Debian packaging) replace debianwordpress.dev with your domain name (or localhost if running on the same box as your browser). At time of writing this provides WordPress v3.6.1. WordPress v3.7.1 is available in Testing and Unstable. I haven’t tested it but it should install fine on Wheezy. Upgrading the installed WordPress versionFor keep your WordPress up to date and receive security fixes use Debian package manager: # apt-get update &amp;&amp; apt-get upgrade If you would like to use a more recent version of WordPress, consider using Backports or Debian testing. An alternate installation methodI believe this method conforms more with how the maintainer recommends it should be done. Various sources are drawn upon using this method, and it is also affected by a few bugs as at this writing. It is basically centric around a “kind of” multisite install, but I recommend this method even for a single blog, otherwise when you decide down the track to have more than one and share the packages’ codebase, you’ll have a fair bit of work on your hands. The key useful script here is /usr/share/doc/wordpress/examples/setup-mysql. This gem does a few things: Creates a WordPress config file under /etc/wordpress Creates the WordPress database and user Sets up a wp-content structure under /srv/www/wp-content/DOMAIN (this is key for a non-WordPress multisite install, which is covered more below) Install required packages# apt-get install wordpress apache2 mysql-server Run the helper scriptNow run /usr/share/doc/wordpress/examples/setup-mysql, passing an argument of your site name; eg. myblog.com. You will most probably need other arguments too – just try an initial -h to get help. At this point, as per above, you should have a database created for you, and the /etc/wordpress/config-myblog.com.php config file. Peruse that and sanity check it. Create the Apache siteQuoting /usr/share/doc/wordpress/examples/apache.conf: There are several ways to setup Wordpress &amp; Apache in Debian. However the maintainer’s recommended way with the helper script setup-mysql uses: ## Virtual host VirtualDocumentRoot NameVirtualHost *:80 &lt;VirtualHost *:80&gt; UseCanonicalName Off VirtualDocumentRoot /usr/share/wordpress Options All # wp-content in /srv/www/wp-content/$0 RewriteEngine On RewriteRule ^/wp-content/(.*)$ /srv/www/wp-content/%{HTTP_HOST}/$1 &lt;/VirtualHost&gt; For this configuration to work you’ll also need to have mod_rewrite and mod_vhost_alias loaded and working in Apache. To enable these modules run # a2enmod rewrite &amp;&amp; a2enmod vhost_alias &amp;&amp; service apache2 restart Place this config into something like /etc/apache2/sites-available/myblog.com and modify according to your needs (IP-based virtual host, name-based, logging, etc.) If you’re using any Wordpress functionality that requires URL rewriting (such as permalinks), then you will also need something like this in your Apache config: RewriteRule ^index.php$ - \\[L\\] RewriteCond /usr/share/wordpress%{REQUEST_URI} !-f RewriteCond /usr/share/wordpress%{REQUEST_URI} !-d RewriteRule . /usr/share/wordpress/index.php \\[L\\] # Also needed if using PHP-FPM / Fast-CGI RewriteCond %{REQUEST_URI} !^/php5-fcgi/* The above rewrite conditions rely on Apache finding the required files in /usr/share/wordpress for non-permalinks (such as wp-admin). This may require the following line to ensure it finds the index file when requesting /wp-admin/ DirectoryIndex index.php Final reading before actual configurationNow would be a great time to read /usr/share/doc/wordpress/README.Debian if you haven’t already. All the rest of the pieces should fall into place once you do. Amongst other things, it explains the great way that the Debian WordPress package utilises the WordPress wp-config.php framework, and more importantly, how to handle the infamous “themes” and “plugins” directories in a WordPress install. The key point is that by symlinking under /var/lib/wordpress, users better abide by the FilesystemHierarchyStandard, and can use the in-app upgrade mechanisms of WordPress to upgrade plugins and themes, without clobbering the package, and risking server security. It also discusses the two choices regarding multisite installs, of which this here describes the non-WordPress version. Enable the Apache siteNow we enable the Apache site config made earlier using a2ensite, which basically just creates a symlink in /etc/apache2/sites-enabled from sites-available, then reload Apache: # a2ensite myblog.com# service apache2 reload Configure WordPressNow, browse to your new domain, and follow the normal WP configuration process, and you should be done. IssuesSadly at this point, there are some issues with symlinking, and messing around generally with WP_CONTENT_DIR. The main bug is being tracked at http://core.trac.wordpress.org/ticket/16953. At this point, basically a fair few things break, especially if plugin or theme authors don’t do things right when determining correct filesystem and URI paths to use. There seems no easy fix right now, other than not using symlinks or non-standard (but configurable!) paths. See also Sample configurations can be found in /usr/share/doc/wordpress/examples/ Debian specific instructions are /usr/share/doc/wordpress/README.Debian LAMP External links Home Page WordPress Online Documentation WordPress Manual Update Guide WordPress (最后修改时间 2017-06-10 18:26:06)","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.cobsun.com/categories/操作系统/"}],"tags":[{"name":"debian","slug":"debian","permalink":"https://www.cobsun.com/tags/debian/"},{"name":"linux","slug":"linux","permalink":"https://www.cobsun.com/tags/linux/"},{"name":"PHP","slug":"PHP","permalink":"https://www.cobsun.com/tags/PHP/"},{"name":"wordpress","slug":"wordpress","permalink":"https://www.cobsun.com/tags/wordpress/"}]},{"title":"什么时候该使用 LVM？","slug":"e4-bb-80-e4-b9-88-e6-97-b6-e5-80-99-e8-af-a5-e4-bd-bf-e7-94-a8-lvm-ef-bc-9f","date":"2016-04-11T01:15:22.000Z","updated":"2018-12-12T09:05:36.286Z","comments":true,"path":"2016/04/11/e4-bb-80-e4-b9-88-e6-97-b6-e5-80-99-e8-af-a5-e4-bd-bf-e7-94-a8-lvm-ef-bc-9f/","link":"","permalink":"https://www.cobsun.com/2016/04/11/e4-bb-80-e4-b9-88-e6-97-b6-e5-80-99-e8-af-a5-e4-bd-bf-e7-94-a8-lvm-ef-bc-9f/","excerpt":"","text":"Linux 2.4 之后就开始在内核上支持 LVM 分区管理模式了，具体介绍网上一搜一大堆，找了下适用情况： 使用 LVM 的优势： 文件系统可以跨多个磁盘，因此大小不会受物理磁盘的限制。 可以在系统运行状态下动态地扩展文件系统大小。 可以增加新磁盘到 LVM 的存储池中。 可以以镜像的方式冗余重要数据到多个物理磁盘上。 可以很方便地导出整个卷组，并导入到另外一台机器上。 使用 LVM 的限制： 在从卷组中移除一个磁盘时必须使用 reducevg，否则会出问题。 当卷组中的一个磁盘损坏时，整个卷组都会受影响。 不能减小文件系统大小（受文件系统类型限制）。 因为加入了额外的操作，存储性能会受影响（使用 Stripe 的情况另当别论）。 使用 LVM 将获得更好的可扩展性和可操作性，但却损失了可靠性和存储性能，总的说来就是在这两者间选择。 使用要点 按需分配文件系统大小，不要一次性分配太大的空间给文件系统，剩余的空间可以放在存储池中，在需要时再扩充到文件系统中。 把不同的数据放在不同的卷组中，这样在做系统升级或数据迁移操作时会比较方便。","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"},{"name":"操作系统","slug":"技术分类/操作系统","permalink":"https://www.cobsun.com/categories/技术分类/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.cobsun.com/tags/linux/"},{"name":"lvm","slug":"lvm","permalink":"https://www.cobsun.com/tags/lvm/"}]},{"title":"重装win7后，修复ubuntu引导方法","slug":"e9-87-8d-e8-a3-85win7-e5-90-8e-ef-bc-8c-e4-bf-ae-e5-a4-8dubuntu-e5-bc-95-e5-af-bc-e6-96-b9-e6-b3-95","date":"2016-03-19T09:33:44.000Z","updated":"2018-12-12T09:13:43.668Z","comments":true,"path":"2016/03/19/e9-87-8d-e8-a3-85win7-e5-90-8e-ef-bc-8c-e4-bf-ae-e5-a4-8dubuntu-e5-bc-95-e5-af-bc-e6-96-b9-e6-b3-95/","link":"","permalink":"https://www.cobsun.com/2016/03/19/e9-87-8d-e8-a3-85win7-e5-90-8e-ef-bc-8c-e4-bf-ae-e5-a4-8dubuntu-e5-bc-95-e5-af-bc-e6-96-b9-e6-b3-95/","excerpt":"","text":"电脑本来是win7+ubuntu12.04双系统，后来格式化c盘重装了win7，没了ubuntu的引导，网上试了一些方法，成功恢复了引导。下面是方法： 用u盘做成ubuntu启动盘，或者用刻好的光盘也行，从u盘启动，选择试用ubuntu，不要安装。进入系统后，打开终端： sudo -i //取得root权限 fdisk -l //查看分区信息，找出你的linux的分区，比如我的是sda9 mount /dev/sda9 /mnt //挂载你的boot分区 grub-install –root-directory=/mnt /dev/sda //修复grub 输入完之后如果出现no error report，就已经成功了。 然后重启电脑，就可以看到熟悉的grub启动列表了。 不过还没完，现在只是能进去ubuntu，win7进不去了，然后还要进入ubuntu，打开终端输入： sudo update-grub //更新grub 这样才能启动win7.","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"},{"name":"操作系统","slug":"技术分类/操作系统","permalink":"https://www.cobsun.com/categories/技术分类/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.cobsun.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.cobsun.com/tags/ubuntu/"}]},{"title":"态类型的属性赋值","slug":"e6-80-81-e7-b1-bb-e5-9e-8b-e7-9a-84-e5-b1-9e-e6-80-a7-e8-b5-8b-e5-80-bc","date":"2016-01-11T07:08:12.000Z","updated":"2018-12-12T09:11:08.931Z","comments":true,"path":"2016/01/11/e6-80-81-e7-b1-bb-e5-9e-8b-e7-9a-84-e5-b1-9e-e6-80-a7-e8-b5-8b-e5-80-bc/","link":"","permalink":"https://www.cobsun.com/2016/01/11/e6-80-81-e7-b1-bb-e5-9e-8b-e7-9a-84-e5-b1-9e-e6-80-a7-e8-b5-8b-e5-80-bc/","excerpt":"","text":"可以向动态类型的属性赋值，属性名都是动态生成的，所以在输入时是没有智能提示的，因为是运行时才解析，所以，赋值和取值时的属性名字一定要一致，不然就取不到值了。 举个例子： dynamic dd = new ExpandoObject();// 赋值dd.Name = “小王”;dd.Age = 35; // 取值Console.WriteLine($”此人名叫 {dd.Name} ，年龄 {dd.Age}。”); ExpandoObject是专为动态行为而设计的类型，因为此时要向动态类型的实例的属性赋值，因此属于复合类型，在用dynamic关键字声明变量后，就必须用一个类来实例化，ExpandoObject类就是这个用途。 然后，赋了Name和Age属性的值，属性名字可以随便写，因为是动态的，编译时不会检查；然后在读取属性的值时，属性名一定要和刚才赋值时的名字一致，不然你是取不到值的。 所以得到结果如下： 此人名叫 小王 ，年龄 35。 实际上，ExpandoObject类显式实现了 IDictionary&lt;string,object&gt; 接口，所以，我们可以知道，其实它里面就是用一个字典来存储动态赋值的数值的，键的类型为字符串，表示属性名；值的类型为object，表示任何类型。 不信？咱们把它里面的字典数据输出来： IDictionary dic = (IDictionary)dd;foreach (var pv in dic){ Console.WriteLine($”Key = {pv.Key} , Value = {pv.Value}”);} 然后得到结果如下： Key = Name , Value = 小王 Key = Age , Value = 35 所为为什么不管你如何动态设置属性，它都可以进行解析，就是这个原因，里面用一个字典来负责存取数据。 From http://www.cnblogs.com/tcjiaan/p/5110658.html","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"asp.net","slug":"asp-net","permalink":"https://www.cobsun.com/tags/asp-net/"},{"name":"dynamic","slug":"dynamic","permalink":"https://www.cobsun.com/tags/dynamic/"},{"name":"动态类型","slug":"动态类型","permalink":"https://www.cobsun.com/tags/动态类型/"}]},{"title":"Linux命令行下使用socks代理","slug":"using-socket-proxy-in-linux","date":"2016-01-01T09:18:51.000Z","updated":"2018-12-18T04:16:57.252Z","comments":true,"path":"2016/01/01/using-socket-proxy-in-linux/","link":"","permalink":"https://www.cobsun.com/2016/01/01/using-socket-proxy-in-linux/","excerpt":"","text":"Linux CL下要用socks代理，可以使用 tsocks 这个软件。官网在这里 不过已经很有一段时间没有更新了。 一般发行版的软件源里面相信都有，直接安装即可。 安装完成后，编辑 /etc/tsocks.conf 文件，注意修改下面4行： 1234local = 192.168.1.0/255.255.255.0 //本地不使用代理 server = 192.168.1.1 //代理ip server_port = 1080 //端口 server_type = 5 //socks 4 or 5 保存之后，用 tsocks 打头，如： tsocks apt-get update","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.cobsun.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.cobsun.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://www.cobsun.com/tags/shell/"},{"name":"socket","slug":"socket","permalink":"https://www.cobsun.com/tags/socket/"}]},{"title":"使用国内镜像为composer加速（感谢作者！）","slug":"e4-bd-bf-e7-94-a8-e5-9b-bd-e5-86-85-e9-95-9c-e5-83-8f-e4-b8-bacomposer-e5-8a-a0-e9-80-9f-ef-bc-88-e6-84-9f-e8-b0-a2-e4-bd-9c-e8-80-85-ef-bc-81-ef-bc-89","date":"2016-01-01T09:03:09.000Z","updated":"2018-12-12T09:05:36.308Z","comments":true,"path":"2016/01/01/e4-bd-bf-e7-94-a8-e5-9b-bd-e5-86-85-e9-95-9c-e5-83-8f-e4-b8-bacomposer-e5-8a-a0-e9-80-9f-ef-bc-88-e6-84-9f-e8-b0-a2-e4-bd-9c-e8-80-85-ef-bc-81-ef-bc-89/","link":"","permalink":"https://www.cobsun.com/2016/01/01/e4-bd-bf-e7-94-a8-e5-9b-bd-e5-86-85-e9-95-9c-e5-83-8f-e4-b8-bacomposer-e5-8a-a0-e9-80-9f-ef-bc-88-e6-84-9f-e8-b0-a2-e4-bd-9c-e8-80-85-ef-bc-81-ef-bc-89/","excerpt":"","text":"来源： http://pkg.phpcomposer.com/ Packagist / Composer 中国全量镜像用法：有两种方式启用本镜像服务： 将配置信息添加到 Composer 的配置文件 config.json 中（系统全局配置）。见“例1 （推荐方式）” 将配置信息添加到单个项目的 composer.json 文件中（单个项目配置）。见“例2” 例1：修改 composer 的全局配置文件（推荐方式）打开命令行窗口（windows用户）或控制台（Linux、Mac 用户）并执行如下命令： composer config -g repositories.packagist composer http://packagist.phpcomposer.com 例2：以 laravel 项目的 composer.json 配置文件为例，添加本镜像服务配置信息后如下所示（注意最后几行）：{ &quot;name&quot;: &quot;laravel/laravel&quot;, &quot;description&quot;: &quot;The Laravel Framework.&quot;, &quot;keywords&quot;: [&quot;framework&quot;, &quot;laravel&quot;], &quot;license&quot;: &quot;MIT&quot;, &quot;type&quot;: &quot;project&quot;, &quot;require&quot;: { &quot;php&quot;: &quot;&gt;=5.5.9&quot;, &quot;laravel/framework&quot;: &quot;5.1.*&quot; }, &quot;require-dev&quot;: { &quot;fzaninotto/faker&quot;: &quot;~1.4&quot;, &quot;mockery/mockery&quot;: &quot;0.9.*&quot;, &quot;phpunit/phpunit&quot;: &quot;~4.0&quot;, &quot;phpspec/phpspec&quot;: &quot;~2.1&quot; }, &quot;autoload&quot;: { &quot;classmap&quot;: [ &quot;database&quot; ], &quot;psr-4&quot;: { &quot;App&quot;: &quot;app/&quot; } }, &quot;autoload-dev&quot;: { &quot;classmap&quot;: [ &quot;tests/TestCase.php&quot; ] }, &quot;scripts&quot;: { &quot;post-install-cmd&quot;: [ &quot;php artisan clear-compiled&quot;, &quot;php artisan optimize&quot; ], &quot;pre-update-cmd&quot;: [ &quot;php artisan clear-compiled&quot; ], &quot;post-update-cmd&quot;: [ &quot;php artisan optimize&quot; ], &quot;post-root-package-install&quot;: [ &quot;php -r &quot;copy(&apos;.env.example&apos;, &apos;.env&apos;);&quot;&quot; ], &quot;post-create-project-cmd&quot;: [ &quot;php artisan key:generate&quot; ] }, &quot;config&quot;: { &quot;preferred-install&quot;: &quot;dist&quot; }, &quot;repositories&quot;: [ {&quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;http://packagist.phpcomposer.com&quot;}, {&quot;packagist&quot;: false} ] } 注意：为了避免安装包的时候都要执行两次查询，切记要添加禁用 packagist 的设置，如下： { &quot;repositories&quot;: [ {&quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;http://packagist.phpcomposer.com&quot;}, {&quot;packagist&quot;: false} ] } 说明： 使用本镜像服务就意味着下载的所有的安装包元数据都将来自本镜像服务，而不再向 packagist.org 发起请求。这将加速 Composer 的安装过程，并且更加可靠、快速。（由于众所周知的原因，国外的网站连接速度太慢，并且随时可能被墙） 一般情况下，安装包的数据（zip 文件等）一般是从 GitHub 或其他第三方服务器上下载的，使用本镜像服务后，我们会缓存所有安装包到国内的机房，这样就不必再去向国外的网站发起请求，因此，即使 packagist.org、github.com 或其他第三方服务发生故障（主要是连接速度太慢和被墙），你仍然可以下载、更新安装包。","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[]},{"title":"C#动态post 数据，以招商银行为例（部分代码，）","slug":"c-e5-8a-a8-e6-80-81post-e6-95-b0-e6-8d-ae-ef-bc-8c-e4-bb-a5-e6-8b-9b-e5-95-86-e9-93-b6-e8-a1-8c-e4-b8-ba-e4-be-8b-ef-bc-88-e9-83-a8-e5-88-86-e4-bb-a3-e7-a0-81-ef-bc-8c-ef-bc-89","date":"2015-12-04T08:59:53.000Z","updated":"2018-12-12T08:58:49.110Z","comments":true,"path":"2015/12/04/c-e5-8a-a8-e6-80-81post-e6-95-b0-e6-8d-ae-ef-bc-8c-e4-bb-a5-e6-8b-9b-e5-95-86-e9-93-b6-e8-a1-8c-e4-b8-ba-e4-be-8b-ef-bc-88-e9-83-a8-e5-88-86-e4-bb-a3-e7-a0-81-ef-bc-8c-ef-bc-89/","link":"","permalink":"https://www.cobsun.com/2015/12/04/c-e5-8a-a8-e6-80-81post-e6-95-b0-e6-8d-ae-ef-bc-8c-e4-bb-a5-e6-8b-9b-e5-95-86-e9-93-b6-e8-a1-8c-e4-b8-ba-e4-be-8b-ef-bc-88-e9-83-a8-e5-88-86-e4-bb-a3-e7-a0-81-ef-bc-8c-ef-bc-89/","excerpt":"","text":"genMc.bKey = &quot;AaBbCc1234567890&quot;; genMc.bDate = DateTime.Now.ToString(&quot;yyyyMMdd&quot;); genMc.bBranchID = &quot;0571&quot;; genMc.bCono = &quot;000056&quot;; genMc.bBillno = &quot;TEST&quot; + DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;); genMc.bAmount = &quot;1.23&quot;; genMc.bMerchantPara = &quot;Hello CMBChina&quot;; genMc.bMerchantUrl = &quot;http://www.abc.com/resp.php&quot;; genMc.bPayer = &quot;Buyer1&quot;; genMc.bPayee = &quot;Employeer&quot;; genMc.bIP = &quot;123.123.123.123&quot;; genMc.bGoodType = &quot;54011600&quot;; genMc.bReserved = &quot;&quot;; string mcode = this.CreateMerchantCode(genMc); this.txtMerchantCode.Text = mcode; } protected void btnSubmitPayment_Click(object sender, EventArgs e) { // 拼接交易数据 //StringBuilder _postData = new StringBuilder(); //_postData.Append(&quot;&amp;BranchID=&quot; + this.genMc.bBranchID); //_postData.Append(&quot;&amp;Cono=&quot; + this.genMc.bCono); //_postData.Append(&quot;&amp;BillNo=&quot; + this.genMc.bBillno); //_postData.Append(&quot;&amp;Amount=&quot; + this.genMc.bAmount); //_postData.Append(&quot;&amp;Date=&quot; + this.genMc.bDate); genMc.bKey = &quot;AaBbCc1234567890&quot;; genMc.bDate = DateTime.Now.ToString(&quot;yyyyMMdd&quot;); genMc.bBranchID = &quot;0571&quot;; genMc.bCono = &quot;000056&quot;; genMc.bBillno = DateTime.Now.ToString(&quot;yyMMddHHmm&quot;); genMc.bAmount = &quot;1.23&quot;; genMc.bMerchantPara = &quot;Hello CMBChina&quot;; genMc.bMerchantUrl = &quot;http://www.abc.com/resp.php&quot;; genMc.bPayer = &quot;Buyer1&quot;; genMc.bPayee = &quot;Employeer&quot;; genMc.bIP = &quot;123.123.123.123&quot;; genMc.bGoodType = &quot;54011600&quot;; genMc.bReserved = &quot;&quot;; string _url = &quot;https://netpay.cmbchina.com/netpayment/basehttp.dll?prepayc&quot;; SortedDictionaryparam = new SortedDictionary(); param.Add(&quot;BranchID&quot;, this.genMc.bBranchID); param.Add(&quot;Cono&quot;, this.genMc.bCono); param.Add(&quot;BillNo&quot;, this.genMc.bBillno); param.Add(&quot;Amount&quot;, this.genMc.bAmount); param.Add(&quot;Date&quot;, this.genMc.bDate); //Set a name for the form string formID = &quot;PostForm&quot;; //Build the form using the specified data to be posted. StringBuilder strForm = new StringBuilder(); strForm.Append(&quot; &lt;form id=&quot;&quot;&quot;&quot; name=&quot;&quot;&quot;&quot;&gt;&lt;/form&gt;formID + &quot;&quot; action=&quot;&quot; + _url + &quot;&quot; method=&quot;POST&quot;&gt;&quot;); foreach (var item in param) { strForm.Append(&quot;&lt;input type=&quot;&quot;hidden&quot;&quot; name=&quot;&quot;&quot;&quot; /&gt; &quot;&quot; value=&quot;&quot; + item.Value + &quot;&quot;&gt;&quot;); } strForm.Append(&quot; &quot;); //Build the JavaScript which will do the Posting operation. StringBuilder strScript = new StringBuilder(); strScript.Append(&quot;&lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt;// &lt;![CDATA[ &quot;); strScript.Append(&quot;var v&quot; + formID + &quot; = document.&quot; + formID + &quot;;&quot;); strScript.Append(&quot;v&quot; + formID + &quot;.submit();&quot;); strScript.Append(&quot; // ]]&gt;&lt;/script&gt;&quot;); //Return the form and the script concatenated. //(The order is important, Form then JavaScript) Response.Write(strForm.ToString() + strScript.ToString());","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"asp.net","slug":"asp-net","permalink":"https://www.cobsun.com/tags/asp-net/"},{"name":"c#","slug":"c","permalink":"https://www.cobsun.com/tags/c/"},{"name":"post","slug":"post","permalink":"https://www.cobsun.com/tags/post/"}]},{"title":"复制listview列表里内容","slug":"e5-a4-8d-e5-88-b6listview-e5-88-97-e8-a1-a8-e9-87-8c-e5-86-85-e5-ae-b9","date":"2015-10-22T05:48:35.000Z","updated":"2018-12-12T09:08:58.743Z","comments":true,"path":"2015/10/22/e5-a4-8d-e5-88-b6listview-e5-88-97-e8-a1-a8-e9-87-8c-e5-86-85-e5-ae-b9/","link":"","permalink":"https://www.cobsun.com/2015/10/22/e5-a4-8d-e5-88-b6listview-e5-88-97-e8-a1-a8-e9-87-8c-e5-86-85-e5-ae-b9/","excerpt":"","text":"`//用ctrl + C 复制listview列表里内容 private void listView1_KeyDown(object sender, KeyEventArgs e) { if (e.Control &amp;&amp; e.KeyCode == Keys.C) { if (listView1.SelectedItems.Count &gt; 0) { //将复制的内容放入剪切板中 if (listView1.SelectedItems[0].Text != &quot;&quot;) Clipboard.SetDataObject(listView1.SelectedItems[0].Text); } } }`","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"listview","slug":"listview","permalink":"https://www.cobsun.com/tags/listview/"}]},{"title":"怎样用JS准确的判断浏览器刷新事件","slug":"e6-80-8e-e6-a0-b7-e7-94-a8js-e5-87-86-e7-a1-ae-e7-9a-84-e5-88-a4-e6-96-ad-e6-b5-8f-e8-a7-88-e5-99-a8-e5-88-b7-e6-96-b0-e4-ba-8b-e4-bb-b6","date":"2015-09-25T04:31:05.000Z","updated":"2018-12-12T09:11:08.906Z","comments":true,"path":"2015/09/25/e6-80-8e-e6-a0-b7-e7-94-a8js-e5-87-86-e7-a1-ae-e7-9a-84-e5-88-a4-e6-96-ad-e6-b5-8f-e8-a7-88-e5-99-a8-e5-88-b7-e6-96-b0-e4-ba-8b-e4-bb-b6/","link":"","permalink":"https://www.cobsun.com/2015/09/25/e6-80-8e-e6-a0-b7-e7-94-a8js-e5-87-86-e7-a1-ae-e7-9a-84-e5-88-a4-e6-96-ad-e6-b5-8f-e8-a7-88-e5-99-a8-e5-88-b7-e6-96-b0-e4-ba-8b-e4-bb-b6/","excerpt":"","text":"window.onbeforeunload = function() { var n = window.event.screenX - window.screenLeft; var b = n &gt; document.documentElement.scrollWidth-20; if(b &amp;&amp; window.event.clientY &lt; 0 || window.event.altKey){ alert(&quot;这是一个关闭操作而非刷新&quot;); window.event.returnValue = &quot;&quot;; //此处放你想要操作的代码 }else{ alert(&quot;这是一个刷新操作而非关闭&quot;); } } 来源: http://segmentfault.com/q/1010000000204152","categories":[{"name":"大前端！","slug":"大前端！","permalink":"https://www.cobsun.com/categories/大前端！/"},{"name":"技术分类","slug":"大前端！/技术分类","permalink":"https://www.cobsun.com/categories/大前端！/技术分类/"}],"tags":[{"name":"关闭","slug":"关闭","permalink":"https://www.cobsun.com/tags/关闭/"},{"name":"刷新","slug":"刷新","permalink":"https://www.cobsun.com/tags/刷新/"}]},{"title":"C# 时间戳转换为普通时间","slug":"c-e6-97-b6-e9-97-b4-e6-88-b3-e8-bd-ac-e6-8d-a2-e4-b8-ba-e6-99-ae-e9-80-9a-e6-97-b6-e9-97-b4","date":"2015-08-06T06:02:10.000Z","updated":"2018-12-12T08:58:49.126Z","comments":true,"path":"2015/08/06/c-e6-97-b6-e9-97-b4-e6-88-b3-e8-bd-ac-e6-8d-a2-e4-b8-ba-e6-99-ae-e9-80-9a-e6-97-b6-e9-97-b4/","link":"","permalink":"https://www.cobsun.com/2015/08/06/c-e6-97-b6-e9-97-b4-e6-88-b3-e8-bd-ac-e6-8d-a2-e4-b8-ba-e6-99-ae-e9-80-9a-e6-97-b6-e9-97-b4/","excerpt":"","text":"时间戳转为C#格式时间 // 时间戳转为C#格式时间 private DateTime StampToDateTime(string timeStamp) { DateTime dateTimeStart = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1)); long lTime = long.Parse(timeStamp + &quot;0000000&quot;); TimeSpan toNow = new TimeSpan(lTime); return dateTimeStart.Add(toNow); } DateTime时间格式转换为Unix时间戳格式 // DateTime时间格式转换为Unix时间戳格式 private int DateTimeToStamp(System.DateTime time) { System.DateTime startTime = TimeZone.CurrentTimeZone.ToLocalTime(new System.DateTime(1970, 1, 1)); return (int)(time - startTime).TotalSeconds; }","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"}],"tags":[{"name":"时间","slug":"时间","permalink":"https://www.cobsun.com/tags/时间/"},{"name":"时间戳","slug":"时间戳","permalink":"https://www.cobsun.com/tags/时间戳/"},{"name":"转换","slug":"转换","permalink":"https://www.cobsun.com/tags/转换/"}]},{"title":"ubuntu下怎么使用shadowsocks？","slug":"ubuntu-e4-b8-8b-e6-80-8e-e4-b9-88-e4-bd-bf-e7-94-a8shadowsocks-ef-bc-9f","date":"2015-08-04T02:39:36.000Z","updated":"2018-12-12T09:24:02.238Z","comments":false,"path":"2015/08/04/ubuntu-e4-b8-8b-e6-80-8e-e4-b9-88-e4-bd-bf-e7-94-a8shadowsocks-ef-bc-9f/","link":"","permalink":"https://www.cobsun.com/2015/08/04/ubuntu-e4-b8-8b-e6-80-8e-e4-b9-88-e4-bd-bf-e7-94-a8shadowsocks-ef-bc-9f/","excerpt":"","text":"Ubuntu下怎么使用Shadowsocks？用pip安装就很简单。 安装ssapt-get install python-pip &amp; pip install shadowsocks 启动 ss客户端 启动方法a，直接在终端用命令： sslocal -s 123.123.213.213 -p 6666 -b 127.0.0.1 -l 1080 -k 23333 -t 600 -m aes-256-cfb 2. 启动方法b，用配置文件启动 配置文件存为ss.conf，格式： { &quot;server&quot; : &quot;123.123.213.213&quot;, &quot;server_port&quot; : 6666, &quot;local_port&quot; : 1080, &quot;password&quot; : &quot;23333&quot;, &quot;timeout&quot; : 600, &quot;method&quot; : &quot;aes-256-cfb&quot; } 启动时使用命令： sslocal -c /filepath/to/ss.conf 完成。 **PS：** &gt; a. 记得在Network设置代理: 设置Socks Host指向 ss客户端的本地IP和端口, 即`127.0.0.1 1080`; &gt; b. 有同学反应还是不能科学上网。说明一下，SS不同于VPN，它是走socks5协议的，一般搭配浏览器食用，对于 **terminal的get,wget等走http是没有帮助的**。虽然有socks转http的方法，但这里就不折腾了。 )开机启动ss(可选)在/etc/rc.local中添加启动命令。例如: sudo vi /etc/rc.local 在exit 0前添加(这里假设你已经在第2步写好shell脚本，并命名为`ss_start.sh`) sudo sh /path/to/sslocal/ss_start.sh 如果路径和权限都没问题，在下次开机时就会启动ss了。 查看ss是否已经开启，用下面这个: ps -ef | grep sslocal 输出两条进程信息就说明成功开启了(其中一条是上面这条命令的)。","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"},{"name":"操作系统","slug":"技术分类/操作系统","permalink":"https://www.cobsun.com/categories/技术分类/操作系统/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.cobsun.com/tags/ubuntu/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://www.cobsun.com/tags/shadowsocks/"}]},{"title":"vpn868错误","slug":"vpn868-e9-94-99-e8-af-af","date":"2015-05-14T01:57:38.000Z","updated":"2018-12-12T09:24:02.349Z","comments":true,"path":"2015/05/14/vpn868-e9-94-99-e8-af-af/","link":"","permalink":"https://www.cobsun.com/2015/05/14/vpn868-e9-94-99-e8-af-af/","excerpt":"","text":"vpn868错误解决方法： 一句话：DNS导致的，不要使用自动获取的，可以用8.8.8.8,8.8.4.4等 vpn868错误：未进行远程连接，因为远程访问服务器的名称问题没有解决。","categories":[{"name":"技术分类","slug":"技术分类","permalink":"https://www.cobsun.com/categories/技术分类/"},{"name":"操作系统","slug":"技术分类/操作系统","permalink":"https://www.cobsun.com/categories/技术分类/操作系统/"}],"tags":[{"name":"vpn","slug":"vpn","permalink":"https://www.cobsun.com/tags/vpn/"},{"name":"vpn868错误","slug":"vpn868错误","permalink":"https://www.cobsun.com/tags/vpn868错误/"}]}]}